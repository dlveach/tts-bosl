--[[
  TODO: documentation

	TODO:
	- HUGE: undo for journey
	- add a display for n of 2 students placed per player
	- HUD for scores
	- Bridge UI setAttribute wrapper (save state on bridge UIs)
	- implement state restore
	- implement verbose player logging

]]

env = {}
env.trace = true
env.test = {}
env.test.in_dev = true
env.test.debug = true
env.test.trace = true
env.test.force_fresh_save = true
env.test.test_players = {"Blue","Yellow","Red","Purple"}
-- env.test.test_players = {"Blue","Yellow","Red"}
env.test.hide_start_panel = false

GD = {}

--[[ *****************************
Load function
********************************]]
function onLoad(save_state)
	if env.trace then log("onLoad()") end
	if env.test.force_fresh_save then saved_data = "" end
	--initialize objects
	local board = getObjectFromGUID(C.board_guid)
	if not(env.test.in_dev) then
		board.interactable = false
		for g,_ in pairs(C.markers) do
			getObjectFromGUID(g).interactable = false
		end
		for g,_ in pairs(C.tiles) do
			getObjectFromGUID(g).interactable = false
		end
		getObjectFromGUID(C.trash_guid).interactable = false
	end

	if (saved_data ~= "") then
    log("Global: saved load")
    local restore_data = JSON.decode(saved_data)
    GD = restore_data
    restoreGameState()
  else
		onLoadInit()
	end
end

--[[ *****************************
Save game state
********************************]]
function onSave()
  local saved_data = JSON.encode(GD)
  if env.test.force_fresh_save then
    saved_data = ""
  end
  return saved_data
end

--[[ *****************************
Restore the game state.
********************************]]
function restoreGameState()
	if env.test.trace then log("restoreGameState()") end
	--[[ replay saved global UI setAttributes --]]
	if env.test.debug then log("replay saved global UI setAttributes") end
  for key,value in pairs(GD.states.global_UI) do
    local id = Split(key, '|')[1]
    local field = Split(key, '|')[2]
    local success = UI.setAttribute(id, field, value)
    if not(success) and env.test.debug then
      log("ERROR: restoreGameState(): Unable to setAttribute for global UI"..field.." on id "..id.." to "..tostring(value))
    end
  end
	--[[ replay saved board UI setAttributes --]]
  if env.test.debug then log("replay saved board UI setAttributes") end
  local board = getObjectFromGUID(C.main_board)
  for key,value in pairs(GD.states.board_UI) do
    local id = Split(key, '|')[1]
    local field = Split(key, '|')[2]
    local success = board_UI_setAttribute(id, field, value)
    if not(success) and env.test.debug then
      log("ERROR: restoreGameState(): Unable to setAttribute for board UI"..field.." on id "..id.." to "..tostring(value))
    end
  end
end

--[[ ******************************
Wrapper function for global UI attributes.
Saves attribute update to be replayed on restore.
*********************************]]
function UI_setAttribute(id, field, value)
  if env.test.trace2 then log("UI_setAttribute()") end
  assert(type(id) == "string", "UI_setAttribute(): id must be a string")
  assert(type(field) == "string", "UI_setAttribute(): field must be a string")
  assert(value or value==false, "UI_setAttribute(): value missing")
  GD.states.global_UI[id.."|"..field] = value
  UI.setAttribute(id, field, value)
end

--[[ ******************************
Wrapper function for saving board UI attributes.
Saves attribute update to be replayed on restore.
*********************************]]
function board_UI_setAttribute(id, field, value)
	if env.test.trace2 then log("board_UI_setAttribute()") end
	assert(type(id) == "string", "board_UI_setAttribute(): id must be a string")
	assert(type(field) == "string", "board_UI_setAttribute(): field must be a string")
	assert(value or value==false, "board_UI_setAttribute(): value missing")
	GD.states.board_UI[id.."|"..field] = value
	getObjectFromGUID(C.board_guid).UI.setAttribute(id, field, value)
end

--TODO: Bridge UI setAttribute wrapper

--[[ *****************************
Initial load setup.
********************************]]
function onLoadInit()
	if env.test.trace then log("onLoadInit()") end
	GD.game = {}
	GD.env = {}
	GD.states = {}
	GD.states.global_UI = {}
	GD.states.board_UI = {}
	GD.bridges = {}
	for _,bridge in ipairs(C.bridges) do
		GD.bridges[bridge.guid]=bridge
	end
  GD.cities = simpleDeepCopy(C.cities)
	GD.game.player_order = {}

	GD.env.use_suggested_placement = false
	GD.env.verbose = true
	GD.env.use_student_decals = true

	GD.game.played_tiles = 0
	GD.game.journey_completed = false
	GD.game.closed_cities = 0
	GD.game.used_markers = {}
	GD.game.undo = {}
	GD.game.stage = "init"
	GD.game.current_player = ""

	UI_setAttribute("opt_use_suggested_setup","isOn",GD.env.use_suggested_placement)
	UI_setAttribute("opt_verbose","isOn",GD.env.verbose)
	if not(env.test.hide_start_panel) then
		UI_setAttribute("startPanel","active","true")
	end
end

--[[ *****************************
  UI handler for initial game setup options.
  ********************************]]
function handleOptionsUIBtn(player, value, id)
  if env.test.trace then log("handleOptionsUIBtn()") end
  local setting = (value == 'True')
  UI_setAttribute(id, "isOn", setting)
  if id == "opt_use_suggested_setup" then
    GD.env.use_suggested_placement = setting
		UI_setAttribute("opt_use_suggested_setup","isOn",setting)
  elseif id == "opt_verbose" then
    GD.env.verbose = setting
		UI_setAttribute("opt_verbose","isOn",setting)
  end
end

--[[ *****************************
Button handler for start game dialog.
********************************]]
function startGameBtn(player, btn, id)
	if env.test.trace then log("startGameBtn(): "..player.color) end
	startGame()
end

--[[ *****************************
Start the game after all players are seated.
********************************]]
function startGame()
	if env.test.trace then log("startGame()") end
	--Determine number of players
	local seated = getSeatedPlayers()
	if env.test.test_players then seated = env.test.test_players end
	for _,pcol in ipairs(C.player_colors) do
		if contains(seated, pcol) then
			table.insert(GD.game.player_order, pcol)
		end
	end
	local player_count = #GD.game.player_order
	if player_count < 3 then
		broadcastToAll("3 or 4 players needed to play this game.")
		return
	end
	UI_setAttribute("startPanel","active","false")
	GD.game.current_player = math.random(1,#GD.game.player_order)
	local current = GD.game.player_order[GD.game.current_player]
	if env.test.debug then log("Current player is "..current) end
	if GD.env.use_suggested_placement then
		if player_count == 3 then
			suggested3Player()
		elseif #GD.game.player_order == 4 then
			suggested4Player()
		else
			log("ERROR: startGame(): Invalid player count")
			return
		end
		GD.game.stage = "play"
		for g,_ in pairs(C.tiles) do
			getObjectFromGUID(g).interactable = true
		end
		broadcastToAll("Begin game with suggested initial placement")
	else
		GD.game.stage = "placement"
		for g,d in pairs(C.tiles) do
			getObjectFromGUID(g).interactable = d.i
		end
	end
	updateScores()
	UI_setAttribute("statusPanel","active","true")
	setActivePlayer(false)
	broadcastToAll("Place intial Master Tiles")
end

--[[ *****************************
Setup the game for suggested 3 player initial tile placement.
Includes blocking off City 3.
********************************]]
function suggested3Player()
	if env.test.trace then log("suggested3Player()") end
	for g,td in pairs(C.suggested_3_Player) do
		local tile = getObjectFromGUID(g)
		locateTile(tile, td.city)
	end
	local marker = getObjectFromGUID(C.last_marker)
	local city = GD.cities[3]
	local pos = Vector(city.pos)
	pos.y = 2
	marker.setPosition(pos)
	GD.game.closed_cities = GD.game.closed_cities + 1
	local trash = getObjectFromGUID(C.trash_guid)
	for g,bd in pairs(GD.bridges) do
		if bd.id == 2 or bd.id == 8 or bd.id == 9 then
			log("trash bridge "..g)
			trash.putObject(getObjectFromGUID(g))
			bd.intact = false
		end
	end
	updateCityStrengths()
	updateScores()
end

--[[ *****************************
Setup the game for suggested 4 player initial tile placement.
********************************]]
function suggested4Player()
	if env.test.trace then log("suggested4Player()") end
	for g,td in pairs(C.suggested_4_Player) do
		local tile = getObjectFromGUID(g)
		locateTile(tile, td.city)
	end
	updateCityStrengths()
	updateScores()
end

--[[ *****************************
Sets the active player.  Advance param defaults to true.
********************************]]
function setActivePlayer(advance)
	if advance == nil then advance = true end
	local board = getObjectFromGUID(C.board_guid)
	local current = GD.game.player_order[GD.game.current_player]
	local old = current
	if advance then
		board_UI_setAttribute(current.."PlayerPanel", "active", "false")
		GD.game.current_player = GD.game.current_player + 1
		if GD.game.current_player > 4 then GD.game.current_player = 1 end --wrap
		current = GD.game.player_order[GD.game.current_player]
		if env.test.debug then log("Current player is now "..current) end
		if env.test.test_players then
			Player[old].changeColor(current)
		end
	end
	for _,pcol in ipairs(GD.game.player_order) do
		board_UI_setAttribute(pcol.."UndoPanel","active","false")
		board_UI_setAttribute(pcol.."DonePanel","active",GD.game.stage=="play")
		board_UI_setAttribute(pcol.."JourneyPanel","active",GD.game.stage=="play")
		board_UI_setAttribute(pcol.."PlacementPanel","active",GD.game.stage=="placement")
		board_UI_setAttribute(pcol.."PlayerPanel","active",pcol == current)
	end
	GD.game.undo = {}
	GD.game.played_tiles = 0
	UI_setAttribute("statusActivePlayer","text",current)
	UI_setAttribute("statusActivePlayer","color",current)
	if GD.game.stage == "placement" then
		UI_setAttribute("statusActiveAction","text","Place a Master")
	else
		UI_setAttribute("statusActiveAction","text","Choose an action")
	end
end

--[[ *****************************
Locate ID in the network of nearest city to dropped tile position.  Returns -1 if not found.
TODO: consider finding nearest valid city for tile placement.  Currently only closest of any city.
********************************]]
function findNearestCity(pos)
  assert(pos, "ERROR: findNearestCity(): missing parameter 'pos'")
  if env.test.trace then log("findNearestCity()") end
  local nearest = nil
  local shortest_dist = nil
  for _,city in ipairs(GD.cities) do
    local dist = Vector.sqrDistance(pos, Vector(city.pos))
    if nearest == nil or dist < shortest_dist then
      shortest_dist = dist
      nearest = city
    end
  end
  if env.test.debug then
    log("Closest city is "..tostring(nearest.id))
    log("Distance is "..tostring(shortest_dist))
    log(nearest)
  end
  if nearest then
    return nearest.id
  else
    if env.test.debug then log("ERROR: findNearestCity(): failed to locate a city.") end
    return -1
  end
end

--[[ *****************************
Handle dropping a tile in a city and update network info.
********************************]]
function onObjectDrop(pcol, obj)
  if env.test.trace then log("onObjectDrop(): "..pcol.." dropped "..obj.getGUID()) end
  --ignore non-tile objects
  if obj.tag ~= "Tile" then return end
  --Ignore if dropped off board
  local board = getObjectFromGUID(C.board_guid)
  local center = board.getBounds()["center"]
  local size = board.getBounds()["size"]
  local pos = obj.getPosition()
  if pos.x > center.x + (size.x/2) or pos.x < center.x - (size.x/2) then return end
  if pos.z > center.z + (size.z/2) or pos.z < center.z - (size.z/2) then return end
	--Disallow if game end
	if GD.game.stage == "end" then
		if env.test.debug then log(pcol.." cannot place students after game end") end
		returnTile(obj.getGUID())
		return
	end
	--Disallow if student journey completed
	if GD.game.journey_completed then
		if env.test.debug then log(pcol.." cannot place students after a journey") end
		if GD.env.verbose then broadcastToColor("Cannot place students after a journey", pcol) end
		returnTile(obj.getGUID())
		return
	end
  --Get tile metadata
  local type = C.tiles[obj.getGUID()].t
  assert(type,"ERROR: onObjectDrop(): failed to locate type for "..obj.getGUID())
  local color = C.tiles[obj.getGUID()].c
  assert(color,"ERROR: onObjectDrop(): failed to locate color for "..obj.getGUID())
  if env.test.debug then log("Tile:"..obj.getGUID()..", type:"..type..", color:"..color..", Snap:"..tostring(snap_back)) end
	--disallow dropping more than one tile
	local set = Player[pcol].getSelectedObjects()
	if #set > 1 then
		if env.test.debug then log(pcol.." cannot place multiple tiles on the board at once") end
		if GD.env.verbose then broadcastToColor("Cannot place multiple tiles on the board at once", pcol) end
		returnTile(obj.getGUID())
		return
	end
	--disallow non-active player to place tiles on board
	if pcol != GD.game.player_order[GD.game.current_player] then
		if env.test.debug then log(pcol.." is not the active player") end
		if GD.env.verbose then broadcastToColor("You are not the active player", pcol) end
		returnTile(obj.getGUID())
		return
	end
	--disallow active player placing other's tiles
	if pcol != color then
		if env.test.debug then log(pcol.." cannot place other's tiles") end
		if GD.env.verbose then broadcastToColor("Cannot place other player's tiles", pcol) end
		returnTile(obj.getGUID())
		return
	end
	--Check student tile play limits
	if GD.game.stage == "play" and GD.game.played_tiles == 2 then
		if GD.env.verbose then broadcastToColor("Play no more than 2 Students a turn", pcol) end
		returnTile(obj.getGUID())
		return
	elseif GD.game.stage == "placement" and GD.game.played_tiles == 1 then
		if GD.env.verbose then broadcastToColor("Place only 1 Master a turn", pcol) end
		returnTile(obj.getGUID())
		return
	end
  --Locate nearest city
  local city_id = findNearestCity(obj.getPosition())
  assert(city_id > 0,"ERROR: onObjectDrop(): Could not locate nearest city")
  local city = GD.cities[city_id]
	if city.closed then
		if GD.env.verbose then broadcastToColor("That city is closed to new students", pcol) end
		returnTile(obj.getGUID())
		return
	end
	if city.tiles[obj.getGUID()] ~= nil then
    if env.test.debug then log("ignoring tile drop in same city") end
  else
		if GD.game.stage == "play" then
	    local count = 0
			for tg,_ in pairs(city.tiles) do
	      local tile = C.tiles[tg]
	      if tile.t == type and tile.c ~= color then
	        if env.test.debug then log("another player already played a "..obj.getName().." here") end
					if GD.env.verbose then broadcastToColor("Another player already played a "..obj.getName().." here", pcol) end
					returnTile(obj.getGUID())
	        return
	      elseif tile.t == type and tile.c == color then
	        count = count + 1
	        if count >= 2 then
	          if env.test.debug then log("already a "..obj.getName().." student here, cannot play another") end
						if GD.env.verbose then broadcastToColor("Already a "..obj.getName().." student here, cannot play another", pcol) end
						returnTile(obj.getGUID())
	          return
	        end
	      end
	    end
			if count == 0 then
				if env.test.debug then log("Cannot place new masters during play, only students") end
				if GD.env.verbose then broadcastToColor("Cannot place new masters during play, only students", pcol) end
				returnTile(obj.getGUID())
				return
	    end
	    if env.test.debug then log("valid student for "..obj.getName()) end
			if GD.env.verbose then printToAll(pcol.." places "..obj.getName().." Student in city "..tostring(city.id)) end
			if GD.env.use_student_decals then addDecal(obj.getGUID()) end
		elseif GD.game.stage == "placement" then
			-- no more than 3 tiles per city total (2 for 3 player)
			local pnum = #GD.game.player_order
			if (pnum == 3 and sizeOf(city.tiles) >= 2) or (pnum == 4 and sizeOf(city.tiles) >= 3) then
				if env.test.debug then log("Maximum masters placed in city "..tostring(city.id)) end
				if GD.env.verbose then broadcastToColor("Maximum masters placed in city", pcol) end
				returnTile(obj.getGUID())
				return
			end
			-- cannot play same master as another color
			-- no more than 2 tiles of a color in city (1 for 3 player)
			local count = 0
			for tg,_ in pairs(city.tiles) do
	      local tile = C.tiles[tg]
				if tile.t == type and tile.c ~= color then
					if env.test.debug then log("Another player already played a "..obj.getName().." here") end
					if GD.env.verbose then broadcastToColor("Another player already played a "..obj.getName().." here", pcol) end
					returnTile(obj.getGUID())
					return
				elseif tile.c == color then
	        count = count + 1
				end
			end
			if (pnum == 3 and count >= 1) or (pnum == 4 and count >= 2) then
				if env.test.debug then log("Maximum masters placed in city for player color "..pcol) end
				if GD.env.verbose then broadcastToColor("Maximum masters placed in city for player color "..pcol, pcol) end
				returnTile(obj.getGUID())
				return
			end
			if env.test.debug then log(pcol.." places "..obj.getName().." master in city "..tostring(city.id)) end
			if GD.env.verbose then printToAll(pcol.." places "..obj.getName().." Master in city "..tostring(city.id)) end
		end
  end
	locateTile(obj, city.id)
  local undo = {
    action = "tile_drop",
    guid = obj.getGUID(),
  }
  table.insert(GD.game.undo, undo)
	GD.game.played_tiles = GD.game.played_tiles + 1
	if GD.game.stage == "placement" then
		local board = getObjectFromGUID(C.board_guid)
		board_UI_setAttribute(pcol.."UndoPanel","active","true")
		board_UI_setAttribute(pcol.."DonePanel","active","true")
		board_UI_setAttribute(pcol.."PlacementPanel","active","false")
	else
		local board = getObjectFromGUID(C.board_guid)
		board_UI_setAttribute(pcol.."JourneyPanel","active","false")
		board_UI_setAttribute(pcol.."UndoPanel","active","true")
		UI_setAttribute("statusActiveAction","text","Place Students "..tostring(GD.game.played_tiles).."/2")
	end
	updateCityStrengths()
	updateScores()
end

--[[ *****************************
Locate a tile in the appropriate spot in a city
********************************]]
function locateTile(tile, city_id)
	if env.test.trace then log("locateTile()") end
	local cpos = GD.cities[city_id].pos
	local type = C.tiles[tile.getGUID()].t
	local color = C.tiles[tile.getGUID()].c
  local dx, dz
  if type == "Rain" then dx,dz = -0.5,1
  elseif type == "Astro" then dx,dz = 0.5,1
  elseif type == "Dragon" then dx,dz = -1,0
  elseif type == "Priest" then dx,dz = 0,0
  elseif type == "Yeti" then dx,dz = 1,0
  elseif type == "Fire" then dx,dz = -0.5,-1
  elseif type == "Healer" then dx,dz = 0.5,-1
  else
    log("ERROR: Tile "..tile.getGUID().." has no matching tag")
    return
  end
	tile.setLock(false)
	tile.setVelocity(Vector(0,0,0))
  tile.setPosition(Vector(cpos.x + dx, 2, cpos.z + dz))
	local rank = "master"
	for _,td in pairs(GD.cities[city_id].tiles) do
		if td.t == type and td.c == color then
			rank = "student"
			break
		end
	end
	GD.cities[city_id].tiles[tile.getGUID()] = {t=type, c=color, r=rank}
  Wait.condition(function() tile.setLock(true) end, function() return tile.isDestroyed() or tile.resting end, 5)
end

--[[ *****************************
Update strength displays for cities.
********************************]]
function updateCityStrengths()
	local board = getObjectFromGUID(C.board_guid)
	for i=1,13 do
		board_UI_setAttribute("cityText_"..tostring(i),"text",tostring(sizeOf(GD.cities[i].tiles)))
	end
end

--[[ *****************************
Update player scores for masters in cities.
TODO: implement UI for this
********************************]]
function updateScores()
  if env.test.trace then log("updateScores()") end
  --For each player color, for each city, sum up all masters and cities with at least one master
	GD.game.scores = {}
	for _,pcol in ipairs(GD.game.player_order) do
		GD.game.scores[pcol]={cities=0,masters=0}
	end
	for pcol,score in pairs(GD.game.scores) do
		for _,city in ipairs(GD.cities) do
			local found_master = false
			local masters = 0
			for g,td in pairs(city.tiles) do
				if td.c == pcol then
					if td.r == "master" then
						if not(found_master) then
							score.cities = score.cities + 1
							found_master = true
						end
						masters = masters + 1
					end
				end
			end
			score.masters = score.masters + masters
		end
	end
	if env.test.debug then log(GD.game.scores) end
	for pcol,score in pairs(GD.game.scores) do
		UI_setAttribute(pcol.."_statusCities","text",tostring(score.cities))
		UI_setAttribute(pcol.."_statusMasters","text",tostring(score.masters))
	end
end

--[[ *****************************
Process any undo actions.
TODO: undo a student journey
********************************]]
function undo(pcol)
  if env.test.trace then log("undo(): "..pcol) end
  for _,undo in ipairs(GD.game.undo) do
    if undo.action == "tile_drop" then
      local tile = getObjectFromGUID(undo.guid)
      assert(tile, "ERROR: undo(): no tile found for "..tostring(undo.guid))
      tile.setLock(false)
      local snap_back = C.tiles[undo.guid].p
      assert(snap_back,"ERROR: undo(): failed to locate snap back pos for "..tostring(undo.guid))
      tile.setVelocity(Vector(0,0,0))
      tile.setPosition(snap_back)
			for _,city in ipairs(GD.cities) do
				if city.tiles[tile.getGUID()] != nil then city.tiles[tile.getGUID()] = nil end
			end
			clearDecal(tile.getGUID())
    elseif undo.action == "start-journey" then
			--undo start Journey, not the
			disableBridgeButtons()
    else
      log("ERROR: undo() Unknown action")
    end
  end
	GD.game.undo = {}
	if GD.game.stage == "play" then
		GD.game.played_tiles = 0
	else
		GD.game.played_tiles = GD.game.played_tiles - 1
	end
	local board = getObjectFromGUID(C.board_guid)
	board_UI_setAttribute(pcol.."UndoPanel","active","false")
	board_UI_setAttribute(pcol.."JourneyPanel","active",GD.game.stage=="play")
	board_UI_setAttribute(pcol.."PlacementPanel","active",GD.game.stage=="placement")
	board_UI_setAttribute(pcol.."DonePanel","active",GD.game.stage=="play")
	updateCityStrengths()
	updateScores()
end

--[[ *****************************
Process a student journey.
Called from a bridge when player clicks on an arrow.
params:
	guid:	bridge GUID
	pcol:	player.color
	id:		arrow button id ("upArrow" or "downArrow")
********************************]]
function studentJourney(params)
	if env.test.trace then log("studentJourney()") end
	if env.test.debug then log(params) end
	local bridge_guid = params.guid
	local bridge = GD.bridges[bridge_guid]
	local orgin, dest
	--"upArrow" is moving from smaller number city to bigger.  "downArrow" is moving from bigger to smaller.
	if params.id == "upArrow" then
		if env.test.debug then log("Students move from city "..tostring(bridge.cities[1]).." to city "..tostring(bridge.cities[2])) end
		origin = GD.cities[bridge.cities[1]]
		dest = GD.cities[bridge.cities[2]]
	elseif params.id == "downArrow" then
		if env.test.debug then log("Students move from city "..tostring(bridge.cities[2]).." to city "..tostring(bridge.cities[1])) end
		origin = GD.cities[bridge.cities[2]]
		dest = GD.cities[bridge.cities[1]]
	else
		log("ERROR: studentJourney(): Unknown arrow button id")
		return
	end
	if env.test.debug then log("across bridge id "..tostring(bridge.id)) end
	disableBridgeButtons()

	--build a temp map of the origen and destination city tiles by tile type
	local o = {masters={}, students={}}
	for g,t in pairs(origin.tiles) do
		if t.r == "master" then
			o.masters[t.t]={g=g, c=t.c,}
		else
			o.students[t.t]={g=g, c=t.c,}
		end
	end
	if env.test.debug then
		log("Origen tiles:")
		log(o)
	end
	local d = {masters={}, students={}}
	for g,t in pairs(dest.tiles) do
		if t.r == "master" then
			d.masters[t.t]={g=g, c=t.c,}
		else
			d.students[t.t]={g=g, c=t.c,}
		end
	end
	if env.test.debug then
		log("Destination tiles:")
		log(d)
	end

	--determine winner of strength battle
	local o_str = sizeOf(origin.tiles)
	local o_master_str = sizeOf(o.masters)
	local d_str = sizeOf(dest.tiles)
	local d_master_str = sizeOf(d.masters)
	local o_wins
	if o_str > d_str then
		if env.test.debug then log("Origin > Destination") end
		o_wins = true
	elseif d_str > o_str then
		if env.test.debug then log("Destination > Origen") end
		o_wins = false
	else
		if env.test.debug then log("Cities tied for strength: enter tiebreaker") end
		if o_master_str > d_master_str then
			if env.test.debug then log("Origen wins tiebreaker") end
			o_wins = true
		elseif d_master_str > o_master_str then
			if env.test.debug then log("Destination wins tiebreaker") end
			o_wins = false
		else
			if env.test.debug then log("No tiebreaker, Destination wins") end
			o_wins = false
		end
	end

	--process the tiles for the journey
	if o_wins then
		if env.test.debug then log("Process journey for Origen wins") end
		for t,td in pairs(o.students) do
			local place_tile = true
			if d.students[t] ~= nil then
				if d.students[t].c == td.c then
					--return origen student
					if env.test.debug then log("Already a student, send origin student "..t.." home") end
					returnTile(td.g)
					place_tile = false
				else
					--return other player's dest student and master from destination
					if env.test.debug then log("Sending player's tile(s) home") end
					returnTile(d.students[t].g)
					dest.tiles[d.students[t].g] = nil
					returnTile(d.masters[t].g)
					dest.tiles[d.masters[t].g] = nil
				end
			elseif d.masters[t] ~= nil and d.masters[t].c ~= td.c then
				--return other player's master from destination
				returnTile(d.masters[t].g)
				dest.tiles[d.masters[t].g] = nil
			end
			if place_tile then
				--place the origen student in dest city
				if env.test.debug then log("Placing student in dest city") end
				local tile = getObjectFromGUID(td.g)
				clearDecal(tile.getGUID())
				locateTile(tile, dest.id)
			end
			origin.tiles[td.g] = nil
		end
	else
		if env.test.debug then log("Process journey for Destination wins") end
		for t,td in pairs(o.students) do
			if d.masters[t] ~= nil or d.students[t] ~= nil then
				--return origen student
				if env.test.debug then log("Destination location not empty for type "..t..", send origin student home") end
				returnTile(td.g)
			else
				--place origin student in empty destination space
				if env.test.debug then log("Place origin student in empty destination space for type "..t) end
				local tile = getObjectFromGUID(td.g)
				clearDecal(tile.getGUID())
				locateTile(tile, dest.id)
			end
			origin.tiles[td.g] = nil
		end
	end

	-- Remove the bridge used in the journey
	local b = getObjectFromGUID(bridge_guid)
	assert(b, "ERROR: studentJourney(): no bridge object for guid "..tostring(bridge_guid))
	b.UI.setAttribute("mainPanel","active","false")
	local trash = getObjectFromGUID(C.trash_guid)
	trash.putObject(b)
	GD.bridges[bridge_guid].intact = false
	-- Check for closed cities
	if env.test.debug then log("Evaluate origin bridge connections for closing city") end
	local closed = true
	for _,n in ipairs(origin.neighbors) do
		local bridge_guid = C.bridges[n.bridge].guid		--TODO: refactor bridge meta data to avoid this lookup
		if GD.bridges[bridge_guid].intact then
			closed = false
			break
		end
	end
	if closed then
		Wait.frames(function() closeCity(origin.id) end, 10) --allow any tiles to be placed first
	end
	if env.test.debug then log("Evaluate dest bridge connections for closing city") end
	closed = true
	for _,n in ipairs(dest.neighbors) do
		local bridge_guid = C.bridges[n.bridge].guid		--TODO: refactor bridge meta data to avoid this lookup
		if GD.bridges[bridge_guid].intact then
			closed = false
			break
		end
	end
	if closed then
		Wait.frames(function() closeCity(dest.id) end, 10) --allow any tiles to be placed first
	end

	updateCityStrengths()
	updateScores()
	GD.game.journey_completed = true

	--TODO: handle endgame
	if GD.game.closed_cities == 11 then
		log("TODO: handle end game")
		broadcastToAll("GAME IS OVER")
		log(GD.game.scores)
		for _,pcol in ipairs(GD.game.player_order) do
			board_UI_setAttribute(params.pcol.."buttonPanel","active","false")
		end
		GD.game.stage = "end"
	else
		local board = getObjectFromGUID(C.board_guid)
		board_UI_setAttribute(params.pcol.."DonePanel","active","true")
	end
end

--[[ *****************************
Close a city.  Called when all bridges are gone.
Set closed state and put a marker on the city.
********************************]]
function closeCity(city_id)
	--TODO: undo for this
	if env.test.trace then log("closeCity(): "..tostring(city_id)) end
	GD.game.closed_cities = GD.game.closed_cities + 1
	local city = GD.cities[city_id]
	city.closed = true
	for g,md in pairs(C.markers) do
		if not(contains(GD.game.used_markers, g)) then
			local pos = Vector(city.pos)
			pos.y = pos.y + 1
			local m = getObjectFromGUID(g)
			m.setLock(false)
			-- m.setPositionSmooth(pos,false,false)
			m.setPosition(pos)
			-- Wait.condition(function() m.setLock(true) end, function() return m.resting or m.isDestroyed() end, 5)
			Wait.time(function() m.setLock(true) end, 2)
			table.insert(GD.game.used_markers, g)
			break
		end
	end
end

--[[ *****************************
Return a tile to the original player position
********************************]]
function returnTile(tile_guid)
	if env.test.trace then log("returnTile(): "..tostring(tile_guid)) end
	local snap_back = C.tiles[tile_guid].p
	assert(snap_back,"ERROR: returnTile(): failed to locate snap back pos for "..tostring(tile_guid))
	local tile = getObjectFromGUID(tile_guid)
	assert(tile, "ERROR: returnTile(): no object for tile guid "..tostring(tile_guid))
	clearDecal(tile_guid)
	tile.setLock(false)
	tile.setVelocity(Vector(0,0,0))
	tile.setPosition(snap_back)
end

--[[ *****************************
Return true if city tile list contains at least one student for player color
********************************]]
function hasStudent(tiles, pcol)
	for _,td in pairs(tiles) do
		if td.c == pcol and td.r == "student" then return true end
	end
	return false
end

--[[ *****************************
Enable valid buttons according to student journey limitations in rules
The "downArrow" is moving from smaller number city to bigger.  "upArrow" is moving from bigger to smaller.
Only enable arrows where player has at least one student in source city (city moved from)
********************************]]
function enableBridgeButtons(pcol)
	if env.test.trace then log("enableBridgeButtons(): "..pcol) end
	--First disable all arrows and UI panels
	for g,bd in pairs(GD.bridges) do
		if bd.intact then
			local b = getObjectFromGUID(g)
			b.UI.setAttribute("upPanel", "active", "false")
			b.UI.setAttribute("downPanel", "active", "false")
			b.UI.setAttribute("mainPanel", "active", "false")
		end
	end
	--Search all city -> neighbor paths and enable arrows if at least one source student for player
	for _,city in ipairs(GD.cities) do
		if hasStudent(city.tiles, pcol) then
			--enable all neighbor paths
			for _,neighbor in ipairs(city.neighbors) do
				local bridge = getObjectFromGUID(C.bridges[neighbor.bridge].guid)
				if bridge then
					if neighbor.id > city.id then
						--up arrow
						bridge.UI.setAttribute("upPanel","active","true")
					else
						--down arrow
						bridge.UI.setAttribute("downPanel","active","true")
					end
					bridge.UI.setAttribute("mainPanel","active","true")
				end
			end
		end
	end
end

--[[ *****************************
Disable the arrow buttons on all bridges.
********************************]]
function disableBridgeButtons()
	for g,bd in pairs(GD.bridges) do
		if bd.intact then
			local b = getObjectFromGUID(g)
			b.UI.setAttribute("mainPanel", "active", "false")
		end
	end
end

--[[ *****************************
Add a thick cyan border to a tile, hovering just above it.
Used to indicate a tile is a student.
********************************]]
function addDecal(tile_guid)
	local params = {
    name = "thick-cyan-box",
    position = {["x"]=0,["y"]=0.25,["z"]=0},
    rotation = {["x"]=90,["y"]=180,["z"]=0},
		scale = {["x"]=2,["y"]=2,["z"]=1},
    url = C.student_border_url
  }
	local tile = getObjectFromGUID(tile_guid)
	assert(tile,"ERROR: addDecal(): No object for guid "..tostring(tile_guid))
	tile.addDecal(params)
end

--[[ *****************************
Clear the cyan border from a tile.
********************************]]
function clearDecal(tile_guid)
	local tile = getObjectFromGUID(tile_guid)
	assert(tile,"ERROR: addDecal(): No object for guid "..tostring(tile_guid))
	tile.setDecals({})
end


--[[ *****************************
Handler for UI button clicks
********************************]]
function buttonClick(player, btn, id)
	if env.test.trace then log("buttonClick(): Player: "..player.color..", id: "..id) end
	local pcol = Split(id,'-')[1]
	if player.color ~= pcol then return end --ignore other players
	if player.color ~= GD.game.player_order[GD.game.current_player] then return end
	local action = Split(id,'-')[2]
	if env.test.debug then log("action is "..action) end
	local board = getObjectFromGUID(C.board_guid)
	if action == "done" then
		if GD.game.played_tiles == 7 * #GD.game.player_order then
			broadcastToAll("All initial masters placed, start game play!")
			GD.game.stage = "play"
			for g,_ in pairs(C.tiles) do
				getObjectFromGUID(g).interactable = true
			end
		end
--		if GD.game.stage == "play" then GD.game.played_tiles = 0 end
		GD.game.journey_completed = false
		setActivePlayer()
	elseif action == "undo" then
		undo(player.color)
	elseif action == "journey" then
		enableBridgeButtons(pcol)
		board_UI_setAttribute(pcol.."JourneyPanel","active","false")
		board_UI_setAttribute(pcol.."UndoPanel","active","true")
		board_UI_setAttribute(pcol.."DonePanel","active","false")
		table.insert(GD.game.undo, {action = "start-journey"})
		UI_setAttribute("statusActiveAction","text","Student Journey")
	elseif action == "placement" then
		--ignore TODO: remove this since not a button anymore?
	else
		log("ERROR: buttonClick(): No recognized action.")
		return
	end
end


--//////////////////////////////////////////////////////////////////////////////////////////////////////

--[[ DEV ONLY: build metadata code of objects selected and paste to Notes. ]]
function getPositions(pcol)
  local stuff = Player[pcol].getSelectedObjects()
  local s = ""
  for _,o in ipairs(stuff) do
    local p = o.getPosition()
    -- local t = '["'..o.getGUID()..'"]={t="'..o.getTags()[1]..'", c="'..o.getGMNotes()..'", p={x='..tostring(p.x)..", y="..tostring(p.y)..", z="..tostring(p.z).."},},"
    local t = '["'..o.getGUID()..'"]={p={x='..tostring(p.x)..", y="..tostring(p.y)..", z="..tostring(p.z).."},},"
    log(t)
    s = s .. t .. '\n'
  end
  if s ~= "" then
    Notes.setNotes(s)
  end
end

require("tts-bosl/Constants")
require("tts-lib/utils")
