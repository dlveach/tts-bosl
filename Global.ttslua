--[[
  TODO: documentation

	TODO:
	- HUGE: undo for journey
	- add a display for n of 2 students placed per player
	- HUD for scores
	- Bridge UI setAttribute wrapper (save state on bridge UIs)
	- implement state restore
	- implement verbose player logging

]]

env = {}
env.trace = true
env.test = {}
env.test.in_dev = true
env.test.debug = true
env.test.trace = true
env.test.force_fresh_save = true
env.test.test_players = {"Blue","Yellow","Red","Purple"}
-- env.test.test_players = {"Blue","Yellow","Red"}
env.test.hide_start_panel = false

GD = {}

--[[ *****************************
Load function
********************************]]
function onLoad(save_state)
	if env.trace then log("onLoad()") end
	if env.test.force_fresh_save then saved_data = "" end
	--initialize objects
	local board = getObjectFromGUID(C.board_guid)
	if not(env.test.in_dev) then
		board.interactable = false
		for g,_ in pairs(C.markers) do
			getObjectFromGUID(g).interactable = false
		end
		for g,_ in pairs(C.tiles) do
			getObjectFromGUID(g).interactable = false
		end
		getObjectFromGUID(C.trash_guid).interactable = false
	end

	if (saved_data ~= "") then
    log("Global: saved load")
    local restore_data = JSON.decode(saved_data)
    GD = restore_data
    restoreGameState()
  else
		onLoadInit()
	end
end

--[[ *****************************
Save game state
********************************]]
function onSave()
  local saved_data = JSON.encode(GD)
  if env.test.force_fresh_save then
    saved_data = ""
  end
  return saved_data
end

--[[ *****************************
Restore the game state.
********************************]]
function restoreGameState()
	if env.test.trace then log("restoreGameState()") end
	--[[ replay saved global UI setAttributes --]]
	if env.test.debug then log("replay saved global UI setAttributes") end
  for key,value in pairs(GD.states.global_UI) do
    local id = Split(key, '|')[1]
    local field = Split(key, '|')[2]
    local success = UI.setAttribute(id, field, value)
    if not(success) and env.test.debug then
      log("ERROR: restoreGameState(): Unable to setAttribute for global UI"..field.." on id "..id.." to "..tostring(value))
    end
  end
	--[[ replay saved board UI setAttributes --]]
  if env.test.debug then log("replay saved board UI setAttributes") end
  local board = getObjectFromGUID(C.main_board)
  for key,value in pairs(GD.states.board_UI) do
    local id = Split(key, '|')[1]
    local field = Split(key, '|')[2]
    local success = board_UI_setAttribute(id, field, value)
    if not(success) and env.test.debug then
      log("ERROR: restoreGameState(): Unable to setAttribute for board UI"..field.." on id "..id.." to "..tostring(value))
    end
  end
end

--[[ ******************************
Wrapper function for global UI attributes.
Saves attribute update to be replayed on restore.
*********************************]]
function UI_setAttribute(id, field, value)
  if env.test.trace2 then log("UI_setAttribute()") end
  assert(type(id) == "string", "UI_setAttribute(): id must be a string")
  assert(type(field) == "string", "UI_setAttribute(): field must be a string")
  assert(value or value==false, "UI_setAttribute(): value missing")
  GD.states.global_UI[id.."|"..field] = value
  UI.setAttribute(id, field, value)
end

--[[ ******************************
Wrapper function for saving board UI attributes.
Saves attribute update to be replayed on restore.
*********************************]]
function board_UI_setAttribute(id, field, value)
	if env.test.trace2 then log("board_UI_setAttribute()") end
	assert(type(id) == "string", "board_UI_setAttribute(): id must be a string")
	assert(type(field) == "string", "board_UI_setAttribute(): field must be a string")
	assert(value or value==false, "board_UI_setAttribute(): value missing")
	GD.states.board_UI[id.."|"..field] = value
	getObjectFromGUID(C.board_guid).UI.setAttribute(id, field, value)
end

--TODO: Bridge UI setAttribute wrapper

--[[ *****************************
Initial load setup.
********************************]]
function onLoadInit()
	if env.test.trace then log("onLoadInit()") end
	GD.game = {}
	GD.env = {}
	GD.states = {}
	GD.states.global_UI = {}
	GD.states.board_UI = {}
	GD.bridges = {}
	for _,bridge in ipairs(C.bridges) do
		GD.bridges[bridge.guid]=bridge				--HACK: should I refactor this or C.bridges ???
	end
  GD.cities = simpleDeepCopy(C.cities)
	GD.game.player_order = {}

	GD.env.use_suggested_placement = false
	GD.env.verbose = true
	GD.env.use_student_decals = true

	GD.game.played_tiles = 0
	GD.game.journey_completed = false
	GD.game.closed_cities = 0
	GD.game.used_markers = {}
	GD.game.undo = {}
	GD.game.stage = "init"
	GD.game.current_player = ""

	UI_setAttribute("opt_use_suggested_setup","isOn",GD.env.use_suggested_placement)
	UI_setAttribute("opt_verbose","isOn",GD.env.verbose)
	if not(env.test.hide_start_panel) then
		UI_setAttribute("startPanel","active","true")
	end
end

--[[ *****************************
  UI handler for initial game setup options.
  ********************************]]
function handleOptionsUIBtn(player, value, id)
  if env.test.trace then log("handleOptionsUIBtn()") end
  local setting = (value == 'True')
  UI_setAttribute(id, "isOn", setting)
  if id == "opt_use_suggested_setup" then
    GD.env.use_suggested_placement = setting
		UI_setAttribute("opt_use_suggested_setup","isOn",setting)
  elseif id == "opt_verbose" then
    GD.env.verbose = setting
		UI_setAttribute("opt_verbose","isOn",setting)
  end
end

--[[ *****************************
Button handler for start game dialog.
********************************]]
function startGameBtn(player, btn, id)
	if env.test.trace then log("startGameBtn(): "..player.color) end
	startGame()
end

--[[ *****************************
Start the game after all players are seated.
********************************]]
function startGame()
	if env.test.trace then log("startGame()") end
	--Determine number of players
	local seated = getSeatedPlayers()
	if env.test.test_players then seated = env.test.test_players end
	for _,pcol in ipairs(C.player_colors) do
		if contains(seated, pcol) then
			table.insert(GD.game.player_order, pcol)
		end
	end
	local player_count = #GD.game.player_order
	if player_count < 3 then
		broadcastToAll("3 or 4 players needed to play this game.")
		return
	end
	UI_setAttribute("startPanel","active","false")
	GD.game.current_player = math.random(1,#GD.game.player_order)
	local current = GD.game.player_order[GD.game.current_player]
	if env.test.debug then log("Current player is "..current) end
	if GD.env.use_suggested_placement then
		if player_count == 3 then
			suggested3Player()
		elseif #GD.game.player_order == 4 then
			suggested4Player()
		else
			log("ERROR: startGame(): Invalid player count")
			return
		end
		GD.game.stage = "play"
		for g,_ in pairs(C.tiles) do
			getObjectFromGUID(g).interactable = true
		end
		broadcastToAll("Begin game with suggested initial placement")
	else
		GD.game.stage = "placement"
		for g,d in pairs(C.tiles) do
			getObjectFromGUID(g).interactable = d.i
		end
	end
	updateScores()
	UI_setAttribute("statusPanel","active","true")
	setActivePlayer(false)
	broadcastToAll("Place intial Master Tiles")
end

--[[ *****************************
Setup the game for suggested 3 player initial tile placement.
Includes blocking off City 3.
********************************]]
function suggested3Player()
	if env.test.trace then log("suggested3Player()") end
	for g,td in pairs(C.suggested_3_Player) do
		local tile = getObjectFromGUID(g)
		locateTile(tile, td.city)
	end
	local marker = getObjectFromGUID(C.last_marker)
	local city = GD.cities[3]
	local pos = Vector(city.pos)
	pos.y = 2
	marker.setPosition(pos)
	GD.game.closed_cities = GD.game.closed_cities + 1
	local trash = getObjectFromGUID(C.trash_guid)
	for g,bd in pairs(GD.bridges) do
		if bd.id == 2 or bd.id == 8 or bd.id == 9 then
			log("trash bridge "..g)
			trash.putObject(getObjectFromGUID(g))
			bd.intact = false
		end
	end
	updateCityStrengths()
	updateScores()
end

--[[ *****************************
Setup the game for suggested 4 player initial tile placement.
********************************]]
function suggested4Player()
	if env.test.trace then log("suggested4Player()") end
	for g,td in pairs(C.suggested_4_Player) do
		local tile = getObjectFromGUID(g)
		locateTile(tile, td.city)
	end
	updateCityStrengths()
	updateScores()
end

--[[ *****************************
Sets the active player.  Advance param defaults to true.
********************************]]
function setActivePlayer(advance)
	if advance == nil then advance = true end
	local board = getObjectFromGUID(C.board_guid)
	local current = GD.game.player_order[GD.game.current_player]
	local old = current
	if advance then
		board_UI_setAttribute(current.."PlayerPanel", "active", "false")
		GD.game.current_player = GD.game.current_player + 1
		if GD.game.current_player > 4 then GD.game.current_player = 1 end --wrap
		current = GD.game.player_order[GD.game.current_player]
		if env.test.debug then log("Current player is now "..current) end
		if env.test.test_players then
			Player[old].changeColor(current)
		end
	end
	for _,pcol in ipairs(GD.game.player_order) do
		board_UI_setAttribute(pcol.."UndoPanel","active","false")
		board_UI_setAttribute(pcol.."DonePanel","active",GD.game.stage=="play")
		board_UI_setAttribute(pcol.."JourneyPanel","active",GD.game.stage=="play")
		board_UI_setAttribute(pcol.."PlacementPanel","active",GD.game.stage=="placement")
		board_UI_setAttribute(pcol.."PlayerPanel","active",pcol == current)
	end
	GD.game.undo = {}
	GD.game.played_tiles = 0
	UI_setAttribute("statusActivePlayer","text",current)
	UI_setAttribute("statusActivePlayer","color",current)
	if GD.game.stage == "placement" then
		UI_setAttribute("statusActiveAction","text","Place a Master")
	else
		UI_setAttribute("statusActiveAction","text","Choose an action")
	end
end

--[[ *****************************
Locate ID in the network of nearest city to dropped tile position.  Returns -1 if not found.
TODO: consider finding nearest valid city for tile placement.  Currently only closest of any city.
********************************]]
function findNearestCity(pos)
  assert(pos, "ERROR: findNearestCity(): missing parameter 'pos'")
  if env.test.trace then log("findNearestCity()") end
  local nearest = nil
  local shortest_dist = nil
  for _,city in ipairs(GD.cities) do
    local dist = Vector.sqrDistance(pos, Vector(city.pos))
    if nearest == nil or dist < shortest_dist then
      shortest_dist = dist
      nearest = city
    end
  end
  if env.test.debug then
    log("Closest city is "..tostring(nearest.id))
    log("Distance is "..tostring(shortest_dist))
    log(nearest)
  end
  if nearest then
    return nearest.id
  else
    if env.test.debug then log("ERROR: findNearestCity(): failed to locate a city.") end
    return -1
  end
end

--[[ *****************************
Handle dropping a tile in a city and update network info.
********************************]]
function onObjectDrop(pcol, obj)
  if env.test.trace then log("onObjectDrop(): "..pcol.." dropped "..obj.getGUID()) end
  --ignore non-tile objects
  if obj.tag ~= "Tile" then return end
  --Ignore if dropped off board
  local board = getObjectFromGUID(C.board_guid)
  local center = board.getBounds()["center"]
  local size = board.getBounds()["size"]
  local pos = obj.getPosition()
  if pos.x > center.x + (size.x/2) or pos.x < center.x - (size.x/2) then return end
  if pos.z > center.z + (size.z/2) or pos.z < center.z - (size.z/2) then return end
	--Disallow if game end
	if GD.game.stage == "end" then
		if env.test.debug then log(pcol.." cannot place students after game end") end
		returnTile(obj.getGUID())
		return
	end
	--Disallow if student journey completed
	if GD.game.journey_completed then
		if env.test.debug then log(pcol.." cannot place students after a journey") end
		if GD.env.verbose then broadcastToColor("Cannot place students after a journey", pcol) end
		returnTile(obj.getGUID())
		return
	end
  --Get tile metadata
  local type = C.tiles[obj.getGUID()].t
  assert(type,"ERROR: onObjectDrop(): failed to locate type for "..obj.getGUID())
  local color = C.tiles[obj.getGUID()].c
  assert(color,"ERROR: onObjectDrop(): failed to locate color for "..obj.getGUID())
  if env.test.debug then log("Tile:"..obj.getGUID()..", type:"..type..", color:"..color..", Snap:"..tostring(snap_back)) end
	--disallow dropping more than one tile
	local set = Player[pcol].getSelectedObjects()
	if #set > 1 then
		if env.test.debug then log(pcol.." cannot place multiple tiles on the board at once") end
		if GD.env.verbose then broadcastToColor("Cannot place multiple tiles on the board at once", pcol) end
		returnTile(obj.getGUID())
		return
	end
	--disallow non-active player to place tiles on board
	if pcol != GD.game.player_order[GD.game.current_player] then
		if env.test.debug then log(pcol.." is not the active player") end
		if GD.env.verbose then broadcastToColor("You are not the active player", pcol) end
		returnTile(obj.getGUID())
		return
	end
	--disallow active player placing other's tiles
	if pcol != color then
		if env.test.debug then log(pcol.." cannot place other's tiles") end
		if GD.env.verbose then broadcastToColor("Cannot place other player's tiles", pcol) end
		returnTile(obj.getGUID())
		return
	end
	--Check student tile play limits
	if GD.game.stage == "play" and GD.game.played_tiles == 2 then
		if GD.env.verbose then broadcastToColor("Play no more than 2 Students a turn", pcol) end
		returnTile(obj.getGUID())
		return
	elseif GD.game.stage == "placement" and GD.game.played_tiles == 1 then
		if GD.env.verbose then broadcastToColor("Place only 1 Master a turn", pcol) end
		returnTile(obj.getGUID())
		return
	end
  --Locate nearest city
  local city_id = findNearestCity(obj.getPosition())
  assert(city_id > 0,"ERROR: onObjectDrop(): Could not locate nearest city")
  local city = GD.cities[city_id]
	if city.closed then
		if GD.env.verbose then broadcastToColor("That city is closed to new students", pcol) end
		returnTile(obj.getGUID())
		return
	end
	if city.tiles[obj.getGUID()] ~= nil then
    if env.test.debug then log("ignoring tile drop in same city") end
  else
		if GD.game.stage == "play" then
	    local count = 0
			for tg,_ in pairs(city.tiles) do
	      local tile = C.tiles[tg]
	      if tile.t == type and tile.c ~= color then
	        if env.test.debug then log("another player already played a "..obj.getName().." here") end
					if GD.env.verbose then broadcastToColor("Another player already played a "..obj.getName().." here", pcol) end
					returnTile(obj.getGUID())
	        return
	      elseif tile.t == type and tile.c == color then
	        count = count + 1
	        if count >= 2 then
	          if env.test.debug then log("already a "..obj.getName().." student here, cannot play another") end
						if GD.env.verbose then broadcastToColor("Already a "..obj.getName().." student here, cannot play another", pcol) end
						returnTile(obj.getGUID())
	          return
	        end
	      end
	    end
			if count == 0 then
				if env.test.debug then log("Cannot place new masters during play, only students") end
				if GD.env.verbose then broadcastToColor("Cannot place new masters during play, only students", pcol) end
				returnTile(obj.getGUID())
				return
	    end
	    if env.test.debug then log("valid student for "..obj.getName()) end
			if GD.env.verbose then printToAll(pcol.." places "..obj.getName().." Student in city "..tostring(city.id)) end
			if GD.env.use_student_decals then addDecal(obj.getGUID()) end
		elseif GD.game.stage == "placement" then
			-- no more than 3 tiles per city total (2 for 3 player)
			local pnum = #GD.game.player_order
			if (pnum == 3 and sizeOf(city.tiles) >= 2) or (pnum == 4 and sizeOf(city.tiles) >= 3) then
				if env.test.debug then log("Maximum masters placed in city "..tostring(city.id)) end
				if GD.env.verbose then broadcastToColor("Maximum masters placed in city", pcol) end
				returnTile(obj.getGUID())
				return
			end
			-- cannot play same master as another color
			-- no more than 2 tiles of a color in city (1 for 3 player)
			local count = 0
			for tg,_ in pairs(city.tiles) do
	      local tile = C.tiles[tg]
				if tile.t == type and tile.c ~= color then
					if env.test.debug then log("Another player already played a "..obj.getName().." here") end
					if GD.env.verbose then broadcastToColor("Another player already played a "..obj.getName().." here", pcol) end
					returnTile(obj.getGUID())
					return
				elseif tile.c == color then
	        count = count + 1
				end
			end
			if (pnum == 3 and count >= 1) or (pnum == 4 and count >= 2) then
				if env.test.debug then log("Maximum masters placed in city for player color "..pcol) end
				if GD.env.verbose then broadcastToColor("Maximum masters placed in city for player color "..pcol, pcol) end
				returnTile(obj.getGUID())
				return
			end
			if env.test.debug then log(pcol.." places "..obj.getName().." master in city "..tostring(city.id)) end
			if GD.env.verbose then printToAll(pcol.." places "..obj.getName().." Master in city "..tostring(city.id)) end
		end
  end
	locateTile(obj, city.id)
  local undo = {
    action = "tile_drop",
    guid = obj.getGUID(),
  }
  table.insert(GD.game.undo, undo)
	GD.game.played_tiles = GD.game.played_tiles + 1
	if GD.game.stage == "placement" then
		local board = getObjectFromGUID(C.board_guid)
		board_UI_setAttribute(pcol.."UndoPanel","active","true")
		board_UI_setAttribute(pcol.."DonePanel","active","true")
		board_UI_setAttribute(pcol.."PlacementPanel","active","false")
	else
		local board = getObjectFromGUID(C.board_guid)
		board_UI_setAttribute(pcol.."JourneyPanel","active","false")
		board_UI_setAttribute(pcol.."UndoPanel","active","true")
		UI_setAttribute("statusActiveAction","text","Place Students "..tostring(GD.game.played_tiles).."/2")
	end
	updateCityStrengths()
	updateScores()
end

--[[ *****************************
Locate a tile in the appropriate spot in a city
********************************]]
function locateTile(tile, city_id)
	if env.test.trace then log("locateTile() "..tostring(tile)..", city id "..tostring(city_id)) end
	local cpos = GD.cities[city_id].pos
	local type = C.tiles[tile.getGUID()].t
	local color = C.tiles[tile.getGUID()].c
  local dx, dz
  if type == "Rain" then dx,dz = -0.5,1
  elseif type == "Astro" then dx,dz = 0.5,1
  elseif type == "Dragon" then dx,dz = -1,0
  elseif type == "Priest" then dx,dz = 0,0
  elseif type == "Yeti" then dx,dz = 1,0
  elseif type == "Fire" then dx,dz = -0.5,-1
  elseif type == "Healer" then dx,dz = 0.5,-1
  else
    log("ERROR: Tile "..tile.getGUID().." has no matching tag")
    return
  end
	tile.setLock(false)
	tile.setVelocity(Vector(0,0,0))
  tile.setPosition(Vector(cpos.x + dx, 2, cpos.z + dz))
	local rank = "master"
	for _,td in pairs(GD.cities[city_id].tiles) do
		if td.t == type and td.c == color then
			rank = "student"
			break
		end
	end
	GD.cities[city_id].tiles[tile.getGUID()] = {t=type, c=color, r=rank}
  Wait.condition(function() tile.setLock(true) end, function() return tile.isDestroyed() or tile.resting end, 5)
end

--[[ *****************************
Update strength displays for cities.
********************************]]
function updateCityStrengths()
	if env.test.trace then log("updateCityStrengths()") end
	local board = getObjectFromGUID(C.board_guid)
	for i=1,13 do
		board_UI_setAttribute("cityText_"..tostring(i),"text",tostring(sizeOf(GD.cities[i].tiles)))
	end
end

--[[ *****************************
Update player scores for masters in cities.
TODO: implement UI for this
********************************]]
function updateScores()
  if env.test.trace then log("updateScores()") end
  --For each player color, for each city, sum up all masters and cities with at least one master
	GD.game.scores = {}
	for _,pcol in ipairs(GD.game.player_order) do
		GD.game.scores[pcol]={cities=0,masters=0}
	end
	for pcol,score in pairs(GD.game.scores) do
		for _,city in ipairs(GD.cities) do
			local found_master = false
			local masters = 0
			for g,td in pairs(city.tiles) do
				if td.c == pcol then
					if td.r == "master" then
						if not(found_master) then
							score.cities = score.cities + 1
							found_master = true
						end
						masters = masters + 1
					end
				end
			end
			score.masters = score.masters + masters
		end
	end
	-- if env.test.debug then log(GD.game.scores) end
	for pcol,score in pairs(GD.game.scores) do
		UI_setAttribute(pcol.."_statusCities","text",tostring(score.cities))
		UI_setAttribute(pcol.."_statusMasters","text",tostring(score.masters))
	end
end

--[[ *****************************
Process any undo actions.
TODO: undo a student journey
********************************]]
function undo(pcol)
  if env.test.trace then log("undo(): "..pcol) end
	local needs_update = true
  for _,undo in ipairs(GD.game.undo) do
    if undo.action == "tile_drop" then
      local tile = getObjectFromGUID(undo.guid)
      assert(tile, "ERROR: undo(): no tile found for "..tostring(undo.guid))
      tile.setLock(false)
      local snap_back = C.tiles[undo.guid].p
      assert(snap_back,"ERROR: undo(): failed to locate snap back pos for "..tostring(undo.guid))
      tile.setVelocity(Vector(0,0,0))
      tile.setPosition(snap_back)
			for _,city in ipairs(GD.cities) do
				if city.tiles[tile.getGUID()] != nil then city.tiles[tile.getGUID()] = nil end
			end
			clearDecal(tile.getGUID())
    elseif undo.action == "select-journey" then
			--undo Journey button click
			disableBridgeButtons()
		elseif undo.action == "start-journey" then

			--TODO: implement journey ack dialog

		elseif undo.action == "journey" then
			GD.game.journey_completed = false
			--return markers (if any)
			if undo.markers ~= nil then
				if env.test.debug then log("Undo marker placement") end
				for _,undo_data in ipairs(undo.markers) do
					local marker = getObjectFromGUID(undo_data.guid)
					assert(marker,"ERROR: undo(): No obj for marker guid "..tostring(undo_data.guid))
					marker.setPosition(C.markers[marker.getGUID()].p)
					table.remove(GD.game.used_markers,indexOf(GD.game.used_markers, undo_data.guid))
					--open city back up
					GD.game.closed_cities = GD.game.closed_cities - 1
					GD.cities[undo_data.city_id].closed = false
				end
			end
			--replace bridge from trash bag
			if undo.bridge ~= nil then
				if env.test.debug then log("Undo trash bridge") end
				local params = {
					guid = undo.bridge.guid,
					position = undo.bridge.position,
					rotation = undo.bridge.rotation,
					callback_function = function(obj)
						Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 3)
					end,
					}
				local trash = getObjectFromGUID(C.trash_guid)
				trash.takeObject(params)
				GD.bridges[undo.bridge.guid].intact = true
			else
				log("ERROR: undo(): No bridge data for journey undo")
			end
			--return students from destination to origin (if any)
			if undo.placed_students ~= nil then
				if env.test.debug then log("Undo students placed in destination") end
				for _,g in ipairs(undo.placed_students) do
					local tile = getObjectFromGUID(g)
					locateTile(tile, undo.orig_id)
					if GD.env.use_student_decals then addDecal(g) end
					GD.cities[undo.dest_id].tiles[g] = nil
				end
			end
			--return displaced masters to destination (if any)
			Wait.frames(function()
				if undo.displaced_masters ~= nil then
					if env.test.debug then log("Undo masters displaced from destination") end
					for _,g in ipairs(undo.displaced_masters) do
						local tile = getObjectFromGUID(g)
						locateTile(tile, undo.dest_id)
					end
				end
			end, 30)
			--return displaced students to destination (if any)
			Wait.frames(function()
				if undo.displaced_students ~= nil then
					if env.test.debug then log("Undo students displaced from destination") end
					for _,g in ipairs(undo.displaced_students) do
						local tile = getObjectFromGUID(g)
						locateTile(tile, undo.dest_id)
						if GD.env.use_student_decals then addDecal(g) end
					end
				end
			end, 60)
			--return displaced students to origin (if any)
			Wait.frames(function()
				if undo.displaced_origin_students ~= nil then
					if env.test.debug then log("Undo students displaced from origin") end
					for _,g in ipairs(undo.displaced_origin_students) do
						local tile = getObjectFromGUID(g)
						locateTile(tile, undo.orig_id)
						if GD.env.use_student_decals then addDecal(g) end
					end
				end
				updateCityStrengths()
				updateScores()
				needs_update = false
			end, 90)
    else
      log("ERROR: undo() Unknown action")
    end
  end
	GD.game.undo = {}
	if GD.game.stage == "play" then
		GD.game.played_tiles = 0
	else
		GD.game.played_tiles = GD.game.played_tiles - 1
	end
	local board = getObjectFromGUID(C.board_guid)
	board_UI_setAttribute(pcol.."UndoPanel","active","false")
	board_UI_setAttribute(pcol.."JourneyPanel","active",GD.game.stage=="play")
	board_UI_setAttribute(pcol.."PlacementPanel","active",GD.game.stage=="placement")
	board_UI_setAttribute(pcol.."DonePanel","active",GD.game.stage=="play")
	if needs_update then
		--HACK: had to duplicate the updates in last journey undo due to the delay.
		updateCityStrengths()
		updateScores()
	end
end

--[[ *****************************
Setup a student journey for the selected bridge and direction.
Called from a bridge object when player clicks a displayed arrow.
params:
	guid:	bridge GUID
	pcol:	player.color
	id:		arrow button id ("upArrow" or "downArrow")
TODO: just working on a concept here, not yet part of the game
********************************]]
function startStudentJourney(params)
	if env.test.trace then log("startStudentJourney()") end
	if env.test.debug then log(params) end
	GD.game.journey = {}
	local journey = GD.game.journey
	journey.player_color = params.pcol
	journey.bridge_guid = params.guid
	journey.origin = {}
	journey.dest = {}
	--"upArrow" is moving from smaller number city to bigger.  "downArrow" is moving from bigger to smaller.
	local bridge = GD.bridges[journey.bridge_guid]
	if params.id == "upArrow" then
		journey.origin.city = GD.cities[bridge.cities[1]]
		journey.dest.city = GD.cities[bridge.cities[2]]
	elseif params.id == "downArrow" then
		journey.origin.city = GD.cities[bridge.cities[2]]
		journey.dest.city = GD.cities[bridge.cities[1]]
	else
		log("ERROR: startStudentJourney(): Unknown arrow button id")
		return
	end
	GD.game.undo = {action = "start-journey",}
	--setup journey tile data
	journey.origin.masters = {}
	journey.origin.students = {}
	journey.origin.strength = sizeOf(journey.origin.city.tiles)
	for g,td in pairs(journey.origin.city.tiles) do
		if td.r == "master" then
			journey.origin.masters[td.t]={g=g, c=td.c,}
		else
			journey.origin.students[td.t]={g=g, c=td.c,}
		end
	end
	journey.dest.masters = {}
	journey.dest.students = {}
	journey.dest.strength = sizeOf(journey.dest.city.tiles)
	for g,td in pairs(journey.dest.city.tiles) do
		if td.r == "master" then
			journey.dest.masters[td.t]={g=g, c=td.c,}
		else
			journey.dest.students[td.t]={g=g, c=td.c,}
		end
	end
	--determine city winner
	local origin_wins = false
	if journey.origin.strength > journey.dest.strength then
		origin_wins = true
	elseif (journey.origin.strength == journey.dest.strength) and (sizeOf(journey.origin.masters) > sizeOf(journey.dest.masters)) then
		origin_wins = true
	end
	--setup tile actions
	for type,_ in pairs(journey.origin.students) do
		if origin_wins then
			journey.origin.students[type].action = "place"
			if journey.dest.masters[type] != nil then
				journey.dest.masters[type].action = "return"
				if journey.dest.students[type] != nil then
					journey.dest.students[type].action = "return"
				end
			end
		else
			if journey.dest.masters[type] == nil then
				journey.origin.students[type].action = "place"
			else
				journey.origin.students[type].action = "return"
			end
		end
	end
	--determine if city closed
	journey.origin.closed = true
	for _,neigbor in ipairs(journey.origin.city.neighbors) do
		if GD.bridges[C.bridges[neigbor.bridge].guid].intact then		--TODO: refactor bridge meta data to avoid this lookup
			journey.origin.closed = false
			break
		end
	end
	journey.dest.closed = true
	for _,neigbor in ipairs(journey.dest.city.neighbors) do
		if GD.bridges[C.bridges[neigbor.bridge].guid].intact then		--TODO: refactor bridge meta data to avoid this lookup
			journey.dest.closed = false
			break
		end
	end
	if env.test.debug then log(journey) end

	--TODO: display the student journey preview dialog

end

--[[ *****************************
Process a student journey.
Called after player ok's the preview dialog.
********************************]]
function processJourney()
	if env.test.trace then log("studentJourney()") end

	--TODO: implement

end

--[[ *****************************
Process a student journey.
Called from a bridge when player clicks on an arrow.
params:
	guid:	bridge GUID
	pcol:	player.color
	id:		arrow button id ("upArrow" or "downArrow")
--TODO: looking at breaking this apart for a student journey preview
********************************]]
function studentJourney(params)
	if env.test.trace then log("studentJourney()") end
	if env.test.debug then log(params) end
	local bridge_guid = params.guid
	local bridge = GD.bridges[bridge_guid]
	local orgin, dest
	--"upArrow" is moving from smaller number city to bigger.  "downArrow" is moving from bigger to smaller.
	if params.id == "upArrow" then
		if env.test.debug then log("Students move from city "..tostring(bridge.cities[1]).." to city "..tostring(bridge.cities[2])) end
		origin = GD.cities[bridge.cities[1]]
		dest = GD.cities[bridge.cities[2]]
	elseif params.id == "downArrow" then
		if env.test.debug then log("Students move from city "..tostring(bridge.cities[2]).." to city "..tostring(bridge.cities[1])) end
		origin = GD.cities[bridge.cities[2]]
		dest = GD.cities[bridge.cities[1]]
	else
		log("ERROR: studentJourney(): Unknown arrow button id")
		return
	end
	if env.test.debug then log("across bridge id "..tostring(bridge.id)) end
	disableBridgeButtons()
	--reset undo for journey
	local undo = {
		action = "journey",
		orig_id = origin.id,
		dest_id = dest.id,
		markers = {},
		bridge = nil,
		placed_students = {},
		displaced_masters = {},
		displaced_students = {},
		displaced_origin_students = {},
	}
	GD.game.undo = {undo}

	--build a temp map of the origin and destination city tiles by tile type
	local o = {masters={}, students={}}
	for g,t in pairs(origin.tiles) do
		if t.r == "master" then
			o.masters[t.t]={g=g, c=t.c,}
		else
			o.students[t.t]={g=g, c=t.c,}
		end
	end
	-- if env.test.debug then
	-- 	log("Origen tiles:")
	-- 	log(o)
	-- end
	local d = {masters={}, students={}}
	for g,t in pairs(dest.tiles) do
		if t.r == "master" then
			d.masters[t.t]={g=g, c=t.c,}
		else
			d.students[t.t]={g=g, c=t.c,}
		end
	end
	-- if env.test.debug then
	-- 	log("Destination tiles:")
	-- 	log(d)
	-- end

	--determine winner of strength battle
	local o_str = sizeOf(origin.tiles)
	local o_master_str = sizeOf(o.masters)
	local d_str = sizeOf(dest.tiles)
	local d_master_str = sizeOf(d.masters)
	local o_wins
	if o_str > d_str then
		if env.test.debug then log("Origin > Destination") end
		o_wins = true
	elseif d_str > o_str then
		if env.test.debug then log("Destination > Origen") end
		o_wins = false
	else
		if env.test.debug then log("Cities tied for strength: enter tiebreaker") end
		if o_master_str > d_master_str then
			if env.test.debug then log("Origen wins tiebreaker") end
			o_wins = true
		elseif d_master_str > o_master_str then
			if env.test.debug then log("Destination wins tiebreaker") end
			o_wins = false
		else
			if env.test.debug then log("No tiebreaker, Destination wins") end
			o_wins = false
		end
	end

	--process the tiles for the journey
	if o_wins then
		if env.test.debug then log("Process journey for Origen wins") end
		for t,td in pairs(o.students) do
			local place_tile = true
			if d.students[t] ~= nil then
				if d.students[t].c == td.c then
					--return origin student
					if env.test.debug then log("Already a student, send origin student "..t.." home") end
					returnTile(td.g)
					origin.tiles[td.g] = nil
					place_tile = false
					table.insert(undo.displaced_origin_students, td.g)
				else
					--return other player's dest student and master from destination
					if env.test.debug then log("Sending player's tile(s) home") end
					returnTile(d.students[t].g)
					dest.tiles[d.students[t].g] = nil
					table.insert(undo.displaced_students, d.students[t].g)
					returnTile(d.masters[t].g)
					dest.tiles[d.masters[t].g] = nil
					table.insert(undo.displaced_masters, d.masters[t].g)
				end
			elseif d.masters[t] ~= nil and d.masters[t].c ~= td.c then
				--return other player's master from destination
				returnTile(d.masters[t].g)
				dest.tiles[d.masters[t].g] = nil
				table.insert(undo.displaced_masters, d.masters[t].g)
			end
			if place_tile then
				--place the origin student in dest city
				if env.test.debug then log("Placing student in dest city") end
				local tile = getObjectFromGUID(td.g)
				clearDecal(tile.getGUID())
				locateTile(tile, dest.id)
				table.insert(undo.placed_students, tile.getGUID())
			end
			origin.tiles[td.g] = nil
		end
	else
		if env.test.debug then log("Process journey for Destination wins") end
		for t,td in pairs(o.students) do
			if d.masters[t] ~= nil or d.students[t] ~= nil then
				--return origin student
				if env.test.debug then log("Destination location not empty for type "..t..", send origin student home") end
				returnTile(td.g)
				table.insert(undo.displaced_origin_students, td.g)
			else
				--place origin student in empty destination space
				if env.test.debug then log("Place origin student in empty destination space for type "..t) end
				local tile = getObjectFromGUID(td.g)
				clearDecal(tile.getGUID())
				locateTile(tile, dest.id)
				table.insert(undo.placed_students, tile.getGUID())
			end
			origin.tiles[td.g] = nil
		end
	end

	-- Remove the bridge used in the journey
	local b = getObjectFromGUID(bridge_guid)
	assert(b, "ERROR: studentJourney(): no bridge object for guid "..tostring(bridge_guid))
	b.UI.setAttribute("mainPanel","active","false")
	undo.bridge = {guid = bridge_guid, position = b.getPosition(), rotation = b.getRotation(),}
	local trash = getObjectFromGUID(C.trash_guid)
	trash.putObject(b)
	GD.bridges[bridge_guid].intact = false
	-- Check for closed cities
	if env.test.debug then log("Evaluate origin bridge connections for closing city") end
	local closed = true
	for _,n in ipairs(origin.neighbors) do
		local bridge_guid = C.bridges[n.bridge].guid		--TODO: refactor bridge meta data to avoid this lookup
		if GD.bridges[bridge_guid].intact then
			closed = false
			break
		end
	end
	if closed then
		Wait.frames(function() closeCity(origin.id) end, 10) --allow any tiles to be placed first
	end
	if env.test.debug then log("Evaluate dest bridge connections for closing city") end
	closed = true
	for _,n in ipairs(dest.neighbors) do
		local bridge_guid = C.bridges[n.bridge].guid		--TODO: refactor bridge meta data to avoid this lookup
		if GD.bridges[bridge_guid].intact then
			closed = false
			break
		end
	end
	if closed then
		Wait.frames(function() closeCity(dest.id) end, 10) --allow any tiles to be placed first
	end

	updateCityStrengths()
	updateScores()
	GD.game.journey_completed = true

	--TODO: handle endgame
	if GD.game.closed_cities == 11 then
		log("TODO: handle end game")
		broadcastToAll("GAME IS OVER")
		log(GD.game.scores)
		for _,pcol in ipairs(GD.game.player_order) do
			board_UI_setAttribute(params.pcol.."buttonPanel","active","false")
		end
		GD.game.stage = "end"
	else
		local board = getObjectFromGUID(C.board_guid)
		board_UI_setAttribute(params.pcol.."DonePanel","active","true")
	end
end

--[[ *****************************
Close a city.  Called when all bridges are gone.
Set closed state and put a marker on the city.
********************************]]
function closeCity(city_id)
	--TODO: undo for this
	if env.test.trace then log("closeCity(): "..tostring(city_id)) end
	if GD.game.undo[1].markers == nil then GD.game.undo[1].markers = {} end
	local undo = {}
	GD.game.closed_cities = GD.game.closed_cities + 1
	local city = GD.cities[city_id]
	city.closed = true
	undo.city_id = city_id
	for g,md in pairs(C.markers) do
		if not(contains(GD.game.used_markers, g)) then
			local pos = Vector(city.pos)
			pos.y = pos.y + 1
			local m = getObjectFromGUID(g)
			m.setLock(false)
			-- m.setPositionSmooth(pos,false,false)
			m.setPosition(pos)
			-- Wait.condition(function() m.setLock(true) end, function() return m.resting or m.isDestroyed() end, 5)
			Wait.time(function() m.setLock(true) end, 2)
			table.insert(GD.game.used_markers, g)
			undo.guid = g
			break
		end
	end
	table.insert(GD.game.undo[1].markers, undo)
end

--[[ *****************************
Return a tile to the original player position
********************************]]
function returnTile(tile_guid)
	if env.test.trace then log("returnTile(): "..tostring(tile_guid)) end
	local snap_back = C.tiles[tile_guid].p
	assert(snap_back,"ERROR: returnTile(): failed to locate snap back pos for "..tostring(tile_guid))
	local tile = getObjectFromGUID(tile_guid)
	assert(tile, "ERROR: returnTile(): no object for tile guid "..tostring(tile_guid))
	clearDecal(tile_guid)
	tile.setLock(false)
	tile.setVelocity(Vector(0,0,0))
	tile.setPosition(snap_back)
end

--[[ *****************************
Return true if city tile list contains at least one student for player color
********************************]]
function hasStudent(tiles, pcol)
	for _,td in pairs(tiles) do
		if td.c == pcol and td.r == "student" then return true end
	end
	return false
end

--[[ *****************************
Enable valid buttons according to student journey limitations in rules
The "downArrow" is moving from smaller number city to bigger.  "upArrow" is moving from bigger to smaller.
Only enable arrows where player has at least one student in source city (city moved from)
********************************]]
function enableBridgeButtons(pcol)
	if env.test.trace then log("enableBridgeButtons(): "..pcol) end
	--First disable all arrows and UI panels
	for g,bd in pairs(GD.bridges) do
		if bd.intact then
			local b = getObjectFromGUID(g)
			b.UI.setAttribute("upPanel", "active", "false")
			b.UI.setAttribute("downPanel", "active", "false")
			b.UI.setAttribute("mainPanel", "active", "false")
		end
	end
	--Search all city -> neighbor paths and enable arrows if at least one source student for player
	for _,city in ipairs(GD.cities) do
		if hasStudent(city.tiles, pcol) then
			--enable all neighbor paths
			for _,neighbor in ipairs(city.neighbors) do
				local bridge = getObjectFromGUID(C.bridges[neighbor.bridge].guid)
				if bridge then
					if neighbor.id > city.id then
						--up arrow
						bridge.UI.setAttribute("upPanel","active","true")
					else
						--down arrow
						bridge.UI.setAttribute("downPanel","active","true")
					end
					bridge.UI.setAttribute("mainPanel","active","true")
				end
			end
		end
	end
end

--[[ *****************************
Disable the arrow buttons on all bridges.
********************************]]
function disableBridgeButtons()
	for g,bd in pairs(GD.bridges) do
		if bd.intact then
			local b = getObjectFromGUID(g)
			b.UI.setAttribute("mainPanel", "active", "false")
		end
	end
end

--[[ *****************************
Add a thick cyan border to a tile, hovering just above it.
Used to indicate a tile is a student.
********************************]]
function addDecal(tile_guid)
	local params = {
    name = "thick-cyan-box",
    position = {["x"]=0,["y"]=0.25,["z"]=0},
    rotation = {["x"]=90,["y"]=180,["z"]=0},
		scale = {["x"]=2,["y"]=2,["z"]=1},
    url = C.student_border_url
  }
	local tile = getObjectFromGUID(tile_guid)
	assert(tile,"ERROR: addDecal(): No object for guid "..tostring(tile_guid))
	tile.addDecal(params)
end

--[[ *****************************
Clear the cyan border from a tile.
********************************]]
function clearDecal(tile_guid)
	local tile = getObjectFromGUID(tile_guid)
	assert(tile,"ERROR: addDecal(): No object for guid "..tostring(tile_guid))
	tile.setDecals({})
end


--[[ *****************************
Handler for UI button clicks
********************************]]
function buttonClick(player, btn, id)
	if env.test.trace then log("buttonClick(): Player: "..player.color..", id: "..id) end
	local pcol = Split(id,'-')[1]
	if player.color ~= pcol then return end --ignore other players
	if player.color ~= GD.game.player_order[GD.game.current_player] then return end
	local action = Split(id,'-')[2]
	if env.test.debug then log("action is "..action) end
	local board = getObjectFromGUID(C.board_guid)
	if action == "done" then
		if GD.game.played_tiles == 7 * #GD.game.player_order then
			broadcastToAll("All initial masters placed, start game play!")
			GD.game.stage = "play"
			for g,_ in pairs(C.tiles) do
				getObjectFromGUID(g).interactable = true
			end
		end
--		if GD.game.stage == "play" then GD.game.played_tiles = 0 end
		GD.game.journey_completed = false
		setActivePlayer()
	elseif action == "undo" then
		undo(player.color)
	elseif action == "journey" then
		enableBridgeButtons(pcol)
		board_UI_setAttribute(pcol.."JourneyPanel","active","false")
		board_UI_setAttribute(pcol.."UndoPanel","active","true")
		board_UI_setAttribute(pcol.."DonePanel","active","false")
		table.insert(GD.game.undo, {action = "select-journey"})
		UI_setAttribute("statusActiveAction","text","Student Journey")
	elseif action == "placement" then
		--ignore TODO: remove this since not a button anymore?
	else
		log("ERROR: buttonClick(): No recognized action.")
		return
	end
end


--//////////////////////////////////////////////////////////////////////////////////////////////////////

--[[ DEV ONLY: build metadata code of objects selected and paste to Notes. ]]
function getPositions(pcol)
  local stuff = Player[pcol].getSelectedObjects()
  local s = ""
  for _,o in ipairs(stuff) do
    local p = o.getPosition()
    -- local t = '["'..o.getGUID()..'"]={t="'..o.getTags()[1]..'", c="'..o.getGMNotes()..'", p={x='..tostring(p.x)..", y="..tostring(p.y)..", z="..tostring(p.z).."},},"
    local t = '["'..o.getGUID()..'"]={p={x='..tostring(p.x)..", y="..tostring(p.y)..", z="..tostring(p.z).."},},"
    log(t)
    s = s .. t .. '\n'
  end
  if s ~= "" then
    Notes.setNotes(s)
  end
end

require("tts-bosl/Constants")
require("tts-lib/utils")
