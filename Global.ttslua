--[[
  TODO: documentation

	TODO:
	- confirmation dialog for Done (pass) if less than 2 students placed
	- HUD for scores
	- implement journey
	- implement journey undo
	- Bridge UI setAttribute wrapper (save state on bridge UIs)
	- implement state restore
	- implement verbose player logging

]]

env = {}
env.trace = true
env.test = {}
env.test.in_dev = true
env.test.debug = true
env.test.trace = true
env.test.force_fresh_save = true
env.test.test_players = {"Blue","Yellow","Red","Purple"}
-- env.test.test_players = {"Blue","Yellow","Red"}
env.test.hide_start_panel = false

GD = {}

--[[ *****************************
Load function
********************************]]
function onLoad(save_state)
	if env.trace then log("onLoad()") end
	if env.test.force_fresh_save then saved_data = "" end
	--initialize objects
	local board = getObjectFromGUID(C.board_guid)
	if not(env.test.in_dev) then
		board.interactable = false
		for g,_ in pairs(C.markers) do
			getObjectFromGUID(g).interactable = false
		end
		for g,_ in pairs(C.tiles) do
			getObjectFromGUID(g).interactable = false
		end
		getObjectFromGUID(C.trash_guid).interactable = false
	end

	if (saved_data ~= "") then
    log("Global: saved load")
    local restore_data = JSON.decode(saved_data)
    GD = restore_data
    restoreGameState()
  else
		onLoadInit()
	end
end

--[[ *****************************
Save game state
********************************]]
function onSave()
  local saved_data = JSON.encode(GD)
  if env.test.force_fresh_save then
    saved_data = ""
  end
  return saved_data
end

--[[ *****************************
Restore the game state.
********************************]]
function restoreGameState()
	if env.test.trace then log("restoreGameState()") end
	--[[ replay saved global UI setAttributes --]]
	if env.test.debug then log("replay saved global UI setAttributes") end
  for key,value in pairs(GD.states.global_UI) do
    local id = Split(key, '|')[1]
    local field = Split(key, '|')[2]
    local success = UI.setAttribute(id, field, value)
    if not(success) and env.test.debug then
      log("ERROR: restoreGameState(): Unable to setAttribute for global UI"..field.." on id "..id.." to "..tostring(value))
    end
  end
	--[[ replay saved board UI setAttributes --]]
  if env.test.debug then log("replay saved board UI setAttributes") end
  local board = getObjectFromGUID(C.main_board)
  for key,value in pairs(GD.states.board_UI) do
    local id = Split(key, '|')[1]
    local field = Split(key, '|')[2]
    local success = board_UI_setAttribute(id, field, value)
    if not(success) and env.test.debug then
      log("ERROR: restoreGameState(): Unable to setAttribute for board UI"..field.." on id "..id.." to "..tostring(value))
    end
  end
end

--[[ ******************************
Wrapper function for global UI attributes.
Saves attribute update to be replayed on restore.
*********************************]]
function UI_setAttribute(id, field, value)
  if env.test.trace2 then log("UI_setAttribute()") end
  assert(type(id) == "string", "UI_setAttribute(): id must be a string")
  assert(type(field) == "string", "UI_setAttribute(): field must be a string")
  assert(value or value==false, "UI_setAttribute(): value missing")
  GD.states.global_UI[id.."|"..field] = value
  UI.setAttribute(id, field, value)
end

--[[ ******************************
Wrapper function for saving board UI attributes.
Saves attribute update to be replayed on restore.
*********************************]]
function board_UI_setAttribute(id, field, value)
	if env.test.trace2 then log("board_UI_setAttribute()") end
	assert(type(id) == "string", "board_UI_setAttribute(): id must be a string")
	assert(type(field) == "string", "board_UI_setAttribute(): field must be a string")
	assert(value or value==false, "board_UI_setAttribute(): value missing")
	GD.states.board_UI[id.."|"..field] = value
	getObjectFromGUID(C.board_guid).UI.setAttribute(id, field, value)
end

--TODO: Bridge UI setAttribute wrapper

--[[ *****************************
Initial load setup.
********************************]]
function onLoadInit()
	if env.test.trace then log("onLoadInit()") end
	GD.game = {}
	GD.env = {}
	GD.states = {}
	GD.states.global_UI = {}
	GD.states.board_UI = {}
	GD.bridges = {}
	for _,bridge in ipairs(C.bridges) do
		GD.bridges[bridge.guid]=bridge
	end
  GD.cities = simpleDeepCopy(C.cities)
	GD.game.player_order = {}

	GD.env.use_suggested_placement = false
	GD.env.verbose = true
	GD.env.use_student_decals = true

	GD.game.played_tiles = 0
	GD.game.undo = {}
	GD.game.stage = "init"
	GD.game.current_player = ""

	UI_setAttribute("opt_use_suggested_setup","isOn",GD.env.use_suggested_placement)
	UI_setAttribute("opt_verbose","isOn",GD.env.verbose)
	if not(env.test.hide_start_panel) then
		UI_setAttribute("startPanel","active","true")
	end
end

--[[ *****************************
  UI handler for initial game setup options.
  ********************************]]
function handleOptionsUIBtn(player, value, id)
  if env.test.trace then log("handleOptionsUIBtn()") end
  local setting = (value == 'True')
  UI_setAttribute(id, "isOn", setting)
  if id == "opt_use_suggested_setup" then
    GD.env.use_suggested_placement = setting
		UI_setAttribute("opt_use_suggested_setup","isOn",setting)
  elseif id == "opt_verbose" then
    GD.env.verbose = setting
		UI_setAttribute("opt_verbose","isOn",setting)
  end
end

--[[ *****************************
Button handler for start game dialog.
********************************]]
function startGameBtn(player, btn, id)
	if env.test.trace then log("startGameBtn(): "..player.color) end
	startGame()
end

--[[ *****************************
Start the game after all players are seated.
********************************]]
function startGame()
	if env.test.trace then log("startGame()") end
	--Determine number of players
	local seated = getSeatedPlayers()
	if env.test.test_players then seated = env.test.test_players end
	for _,pcol in ipairs(C.player_colors) do
		if contains(seated, pcol) then
			table.insert(GD.game.player_order, pcol)
		end
	end
	local player_count = #GD.game.player_order
	if player_count < 3 then
		broadcastToAll("3 or 4 players needed to play this game.")
		return
	end
	UI_setAttribute("startPanel","active","false")
	GD.game.current_player = math.random(1,#GD.game.player_order)
	local current = GD.game.player_order[GD.game.current_player]
	if env.test.debug then log("Current player is "..current) end
	if GD.env.use_suggested_placement then
		if player_count == 3 then
			suggested3Player()
		elseif #GD.game.player_order == 4 then
			suggested4Player()
		else
			log("ERROR: startGame(): Invalid player count")
			return
		end
		GD.game.stage = "play"
		for g,_ in pairs(C.tiles) do
			getObjectFromGUID(g).interactable = true
		end
		broadcastToAll("Begin game with suggested initial placement")
	else
		GD.game.stage = "placement"
		for g,d in pairs(C.tiles) do
			getObjectFromGUID(g).interactable = d.i
		end
	end
	setActivePlayer(false)
	broadcastToAll("Place intial Master Tiles")
end

--[[ *****************************
Setup the game for suggested 3 player initial tile placement.
Includes blocking off City 3.
********************************]]
function suggested3Player()
	if env.test.trace then log("suggested3Player()") end
	for g,td in pairs(C.suggested_3_Player) do
		local tile = getObjectFromGUID(g)
		locateTile(tile, td.city)
	end
	local marker = getObjectFromGUID(C.last_marker)
	local city = GD.cities[3]
	local pos = Vector(city.pos)
	pos.y = 2
	marker.setPosition(pos)
	local trash = getObjectFromGUID(C.trash_guid)
	for g,bd in pairs(GD.bridges) do
		if bd.id == 2 or bd.id == 8 or bd.id == 9 then
			log("trash bridge "..g)
			trash.putObject(getObjectFromGUID(g))
			bd.intact = false
		end
	end
end

--[[ *****************************
Setup the game for suggested 4 player initial tile placement.
********************************]]
function suggested4Player()
	if env.test.trace then log("suggested4Player()") end
	for g,td in pairs(C.suggested_4_Player) do
		local tile = getObjectFromGUID(g)
		locateTile(tile, td.city)
	end
end

--[[ *****************************
Sets the active player.  Advance param defaults to true.
********************************]]
function setActivePlayer(advance)
	if advance == nil then advance = true end
	local board = getObjectFromGUID(C.board_guid)
	local current = GD.game.player_order[GD.game.current_player]
	local old = current
	if advance then
		board_UI_setAttribute(current.."PlayerPanel", "active", "false")
		GD.game.current_player = GD.game.current_player + 1
		if GD.game.current_player > 4 then GD.game.current_player = 1 end --wrap
		current = GD.game.player_order[GD.game.current_player]
		if env.test.debug then log("Current player is now "..current) end
		if env.test.test_players then
			Player[old].changeColor(current)
		end
	end
	for _,pcol in ipairs(GD.game.player_order) do
		board_UI_setAttribute(pcol.."UndoPanel","active","false")
		board_UI_setAttribute(pcol.."DonePanel","active",GD.game.stage=="play")
		board_UI_setAttribute(pcol.."JourneyPanel","active",GD.game.stage=="play")
		board_UI_setAttribute(pcol.."PlacementPanel","active",GD.game.stage=="placement")
		board_UI_setAttribute(pcol.."PlayerPanel","active",pcol == current)
	end
	GD.game.undo = {}
end

--[[ *****************************
Locate ID in the network of nearest city to dropped tile position.  Returns -1 if not found.
TODO: consider finding nearest valid city for tile placement.  Currently only closest of any city.
********************************]]
function findNearestCity(pos)
  assert(pos, "ERROR: findNearestCity(): missing parameter 'pos'")
  if env.test.trace then log("findNearestCity()") end
  local nearest = nil
  local shortest_dist = nil
  for _,city in ipairs(GD.cities) do
    local dist = Vector.sqrDistance(pos, Vector(city.pos))
    if nearest == nil or dist < shortest_dist then
      shortest_dist = dist
      nearest = city
    end
  end
  if env.test.debug then
    log("Closest city is "..tostring(nearest.id))
    log("Distance is "..tostring(shortest_dist))
    log(nearest)
  end
  if nearest then
    return nearest.id
  else
    if env.test.debug then log("ERROR: findNearestCity(): failed to locate a city.") end
    return -1
  end
end

--[[ *****************************
Handle dropping a tile in a city and update network info.
********************************]]
function onObjectDrop(pcol, obj)
  if env.test.trace then log("onObjectDrop(): "..pcol.." dropped "..obj.getGUID()) end
  --ignore non-tile objects
  if obj.tag ~= "Tile" then return end
  --Ignore if dropped off board
  local board = getObjectFromGUID(C.board_guid)
  local center = board.getBounds()["center"]
  local size = board.getBounds()["size"]
  local pos = obj.getPosition()
  if pos.x > center.x + (size.x/2) or pos.x < center.x - (size.x/2) then return end
  if pos.z > center.z + (size.z/2) or pos.z < center.z - (size.z/2) then return end
  --Get tile metadata
  local snap_back = C.tiles[obj.getGUID()].p
  assert(snap_back,"ERROR: onObjectDrop(): failed to locate snap back pos for "..obj.getGUID())
  local type = C.tiles[obj.getGUID()].t
  assert(type,"ERROR: onObjectDrop(): failed to locate type for "..obj.getGUID())
  local color = C.tiles[obj.getGUID()].c
  assert(color,"ERROR: onObjectDrop(): failed to locate color for "..obj.getGUID())
  if env.test.debug then log("Tile:"..obj.getGUID()..", type:"..type..", color:"..color..", Snap:"..tostring(snap_back)) end
	--disallow dropping more than one tile
	local set = Player[pcol].getSelectedObjects()
	if #set > 1 then
		if env.test.debug then log(pcol.." cannot place multiple tiles on the board") end
		obj.setVelocity(Vector(0,0,0))
		obj.setPosition(snap_back)
		return
	end
	--disallow non-active player to place tiles on board
	if pcol != GD.game.player_order[GD.game.current_player] then
		if env.test.debug then log(pcol.." is not the active player") end
		obj.setVelocity(Vector(0,0,0))
		obj.setPosition(snap_back)
		return
	end
	--disallow active player placing other's tiles
	if pcol != color then
		if env.test.debug then log(pcol.." cannot place other's tiles") end
		obj.setVelocity(Vector(0,0,0))
		obj.setPosition(snap_back)
		return
	end
	--Check student tile play limits
	if GD.game.stage == "play" and GD.game.played_tiles == 2 then
		broadcastToColor("Play no more than 2 students", pcol)
		obj.setVelocity(Vector(0,0,0))
		obj.setPosition(snap_back)
		return
	end
  --Locate nearest city
  local city_id = findNearestCity(obj.getPosition())
  assert(city_id > 0,"ERROR: onObjectDrop(): Could not locate nearest city")
  local city = GD.cities[city_id]
	if city.tiles[obj.getGUID()] ~= nil then
    if env.test.debug then log("ignoring tile drop in same city") end
  else
		if GD.game.stage == "play" then
	    local count = 0
			for tg,_ in pairs(city.tiles) do
	      local tile = C.tiles[tg]
	      if tile.t == type and tile.c ~= color then
	        if env.test.debug then log("another player already played a "..obj.getName().." here") end
	        obj.setVelocity(Vector(0,0,0))
	        obj.setPosition(snap_back)
	        return
	      elseif tile.t == type and tile.c == color then
	        count = count + 1
	        if count >= 2 then
	          if env.test.debug then log("already a "..obj.getName().." student here, cannot play another") end
	          obj.setVelocity(Vector(0,0,0))
	          obj.setPosition(snap_back)
	          return
	        end
	      end
	    end
			if count == 0 then
				if env.test.debug then log("Cannot place new masters during play, only students") end
				obj.setVelocity(Vector(0,0,0))
				obj.setPosition(snap_back)
				return
	    end
	    if env.test.debug then log("valid student for "..obj.getName()) end
			if GD.env.use_student_decals then addDecal(obj.getGUID()) end
		elseif GD.game.stage == "placement" then
			-- no more than 3 tiles per city total (2 for 3 player)
			local pnum = #GD.game.player_order
			if (pnum == 3 and sizeOf(city.tiles) >= 2) or (pnum == 4 and sizeOf(city.tiles) >= 3) then
				if env.test.debug then log("Maximum masters placed in city "..tostring(city.id)) end
				obj.setVelocity(Vector(0,0,0))
				obj.setPosition(snap_back)
				return
			end
			-- cannot play same master as another color
			-- no more than 2 tiles of a color in city (1 for 3 player)
			local count = 0
			for tg,_ in pairs(city.tiles) do
	      local tile = C.tiles[tg]
				if tile.t == type and tile.c ~= color then
					if env.test.debug then log("Another player already played a "..obj.getName().." here") end
					obj.setVelocity(Vector(0,0,0))
					obj.setPosition(snap_back)
					return
				elseif tile.c == color then
	        count = count + 1
				end
			end
			if (pnum == 3 and count >= 1) or (pnum == 4 and count >= 2) then
				if env.test.debug then log("Maximum masters placed in city for player color "..pcol) end
				obj.setVelocity(Vector(0,0,0))
				obj.setPosition(snap_back)
				return
			end
			if env.test.debug then log(pcol.." places "..obj.getName().." master in city "..tostring(city.id)) end
		end
  end
	locateTile(obj, city.id)
  local undo = {
    action = "tile_drop",
    guid = obj.getGUID(),
  }
  table.insert(GD.game.undo, undo)
	GD.game.played_tiles = GD.game.played_tiles + 1
	if GD.game.stage == "placement" then
		local board = getObjectFromGUID(C.board_guid)
		board_UI_setAttribute(pcol.."UndoPanel","active","true")
		board_UI_setAttribute(pcol.."DonePanel","active","true")
		board_UI_setAttribute(pcol.."PlacementPanel","active","false")
	else
	  updateScores()
		local board = getObjectFromGUID(C.board_guid)
		board_UI_setAttribute(pcol.."JourneyPanel","active","false")
		board_UI_setAttribute(pcol.."UndoPanel","active","true")
	end
end

--[[ *****************************
Locate a tile in the appropriate spot in a city
********************************]]
function locateTile(tile, city_id)
	if env.test.trace then log("locateTile()") end
	local cpos = GD.cities[city_id].pos
	local type = C.tiles[tile.getGUID()].t
	local color = C.tiles[tile.getGUID()].c
  local dx, dz
  if type == "Rain" then dx,dz = -0.5,1
  elseif type == "Astro" then dx,dz = 0.5,1
  elseif type == "Dragon" then dx,dz = -1,0
  elseif type == "Priest" then dx,dz = 0,0
  elseif type == "Yeti" then dx,dz = 1,0
  elseif type == "Fire" then dx,dz = -0.5,-1
  elseif type == "Healer" then dx,dz = 0.5,-1
  else
    log("ERROR: Tile "..tile.getGUID().." has no matching tag")
    return
  end
	tile.setVelocity(Vector(0,0,0))
  tile.setPosition(Vector(cpos.x + dx, 2, cpos.z + dz))
	local rank = "master"
	for _,td in pairs(GD.cities[city_id].tiles) do
		if td.t == type and td.c == color then
			rank = "student"
			break
		end
	end
	GD.cities[city_id].tiles[tile.getGUID()] = {t=type, c=color, r=rank}
	local board = getObjectFromGUID(C.board_guid)
	board_UI_setAttribute("cityText_"..tostring(city_id),"text",tostring(sizeOf(GD.cities[city_id].tiles)))
  Wait.condition(function() tile.setLock(true) end, function() return tile.isDestroyed() or tile.resting end, 5)
end

--[[ *****************************
Update player scores for masters in cities.
TODO: implement UI for this
********************************]]
function updateScores()
  if env.test.trace then log("updateScores()") end
  --For each player color, for each city, sum up all masters and cities with at least one master
	GD.game.scores = {}
	for _,pcol in ipairs(GD.game.player_order) do
		GD.game.scores[pcol]={cities=0,masters=0}
	end
	for pcol,score in pairs(GD.game.scores) do
		for _,city in ipairs(GD.cities) do
			local found_master = false
			-- local masters = {}
			local masters = 0
			for g,td in ipairs(city.tiles) do
				if td.c == pcol then
					if td.r == "master" then
						if not(found_master) then
							score.cities = score.cities + 1
							found_master = true
						end
						masters = masters + 1
					end
				end
			end
			score.masters = score.masters + masters
		end
	end
	if env.test.debug then log(GD.game.scores) end
end

--[[ *****************************
Process any undo actions.
TODO: undo a student journey
********************************]]
function undo(pcol)
  if env.test.trace then log("undo(): "..pcol) end
  for _,undo in ipairs(GD.game.undo) do
    if undo.action == "tile_drop" then
      local tile = getObjectFromGUID(undo.guid)
      assert(tile, "ERROR: undo(): no tile found for "..tostring(undo.guid))
      tile.setLock(false)
      local snap_back = C.tiles[undo.guid].p
      assert(snap_back,"ERROR: undo(): failed to locate snap back pos for "..tostring(undo.guid))
      tile.setVelocity(Vector(0,0,0))
      tile.setPosition(snap_back)
			for _,city in ipairs(GD.cities) do
				if city.tiles[tile.getGUID()] != nil then city.tiles[tile.getGUID()] = nil end
			end
			clearDecal(tile.getGUID())
    elseif undo.action == "start-journey" then
			--undo start Journey, not the
			disableBridgeButtons()
    else
      log("ERROR: undo() Unknown action")
    end
  end
  updateScores()
	GD.game.undo = {}
	if GD.game.stage == "play" then
		GD.game.played_tiles = 0
	else
		GD.game.played_tiles = GD.game.played_tiles - 1
	end
	local board = getObjectFromGUID(C.board_guid)
	board_UI_setAttribute(pcol.."UndoPanel","active","false")
	board_UI_setAttribute(pcol.."JourneyPanel","active",GD.game.stage=="play")
	board_UI_setAttribute(pcol.."PlacementPanel","active",GD.game.stage=="placement")
	board_UI_setAttribute(pcol.."DonePanel","active",GD.game.stage=="play")
end

--[[ *****************************
Process a student journey.
Called from a bridge when player clicks on an arrow.
params:
	guid:	bridge GUID
	pcol:	player.color
	id:		arrow button id ("upArrow" or "downArrow")
********************************]]
function studentJourney(params)
	if env.test.trace then log("studentJourney()") end
	if env.test.debug then log(params) end
	bridge = GD.bridges[params.guid]
	--"upArrow" is moving from smaller number city to bigger.  "downArrow" is moving from bigger to smaller.
	if params.id == "upArrow" then
		if env.test.debug then log("Students move from city "..tostring(bridge.cities[1]).." to city "..tostring(bridge.cities[2])) end
	else
		if env.test.debug then log("Students move from city "..tostring(bridge.cities[2]).." to city "..tostring(bridge.cities[1])) end
	end
	if env.test.debug then log("across bridge id "..tostring(bridge.id)) end

	disableBridgeButtons()

	--TODO: this moves to journey confirmation dialog?
	local board = getObjectFromGUID(C.board_guid)
	board_UI_setAttribute(params.pcol.."DonePanel","active","true")

end

--[[ *****************************
Return true if city tile list contains at least one student for player color
********************************]]
function hasStudent(tiles, pcol)
	for _,td in pairs(tiles) do
		if td.c == pcol and td.r == "student" then return true end
	end
	return false
end

--[[ *****************************
Enable valid buttons according to student journey limitations in rules
The "downArrow" is moving from smaller number city to bigger.  "upArrow" is moving from bigger to smaller.
Only enable arrows where player has at least one student in source city (city moved from)
********************************]]
function enableBridgeButtons(pcol)
	if env.test.trace then log("enableBridgeButtons(): "..pcol) end
	--First disable all arrows and UI panels
	for g,bd in pairs(GD.bridges) do
		if bd.intact then
			local b = getObjectFromGUID(g)
			b.UI.setAttribute("upPanel", "active", "false")
			b.UI.setAttribute("downPanel", "active", "false")
			b.UI.setAttribute("mainPanel", "active", "false")
		end
	end
	--Search all city -> neighbor paths and enable arrows if at least one source student for player
	for _,city in ipairs(GD.cities) do
		if hasStudent(city.tiles, pcol) then
			--enable all neighbor paths
			for _,neighbor in ipairs(city.neighbors) do
				local bridge = getObjectFromGUID(C.bridges[neighbor.bridge].guid)
				if bridge then
					if neighbor.id > city.id then
						--up arrow
						bridge.UI.setAttribute("upPanel","active","true")
					else
						--down arrow
						bridge.UI.setAttribute("downPanel","active","true")
					end
					bridge.UI.setAttribute("mainPanel","active","true")
				end
			end
		end
	end
end

--[[ *****************************
Disable the arrow buttons on all bridges.
********************************]]
function disableBridgeButtons()
	for g,bd in pairs(GD.bridges) do
		if bd.intact then
			local b = getObjectFromGUID(g)
			b.UI.setAttribute("mainPanel", "active", "false")
		end
	end
end

--[[ *****************************
Add a thick cyan border to a tile, hovering just above it.
Used to indicate a tile is a student.
********************************]]
function addDecal(tile_guid)
	local params = {
    name = "thick-cyan-box",
    position = {["x"]=0,["y"]=0.25,["z"]=0},
    rotation = {["x"]=90,["y"]=180,["z"]=0},
		scale = {["x"]=2,["y"]=2,["z"]=1},
    url = C.student_border_url
  }
	local tile = getObjectFromGUID(tile_guid)
	assert(tile,"ERROR: addDecal(): No object for guid "..tostring(tile_guid))
	tile.addDecal(params)
end

--[[ *****************************
Clear the cyan border from a tile.
********************************]]
function clearDecal(tile_guid)
	local tile = getObjectFromGUID(tile_guid)
	assert(tile,"ERROR: addDecal(): No object for guid "..tostring(tile_guid))
	tile.setDecals({})
end


--[[ *****************************
Handler for UI button clicks
********************************]]
function buttonClick(player, btn, id)
	if env.test.trace then log("buttonClick(): Player: "..player.color..", id: "..id) end
	local pcol = Split(id,'-')[1]
	if player.color ~= pcol then return end --ignore other players
	if player.color ~= GD.game.player_order[GD.game.current_player] then return end
	local action = Split(id,'-')[2]
	if env.test.debug then log("action is "..action) end
	local board = getObjectFromGUID(C.board_guid)
	if action == "done" then
		if GD.game.played_tiles == 7 * #GD.game.player_order then
			broadcastToAll("All initial masters placed, start game play!")
			GD.game.stage = "play"
			for g,_ in pairs(C.tiles) do
				getObjectFromGUID(g).interactable = true
			end
		end
		if GD.game.stage == "play" then GD.game.played_tiles = 0 end
	  GD.game.undo = {}
		setActivePlayer()
	elseif action == "undo" then
		undo(player.color)
	elseif action == "journey" then
		enableBridgeButtons(pcol)
		board_UI_setAttribute(pcol.."JourneyPanel","active","false")
		board_UI_setAttribute(pcol.."UndoPanel","active","true")
		board_UI_setAttribute(pcol.."DonePanel","active","false")
		table.insert(GD.game.undo, {action = "start-journey"})
	elseif action == "placement" then
		--ignore TODO: remove this since not a button anymore?
	else
		log("ERROR: buttonClick(): No recognized action.")
		return
	end
end


--//////////////////////////////////////////////////////////////////////////////////////////////////////

--[[ DEV ONLY: build metadata code of objects selected and paste to Notes. ]]
function getPositions(pcol)
  local stuff = Player[pcol].getSelectedObjects()
  local s = ""
  for _,o in ipairs(stuff) do
    local p = o.getPosition()
    -- local t = '["'..o.getGUID()..'"]={t="'..o.getTags()[1]..'", c="'..o.getGMNotes()..'", p={x='..tostring(p.x)..", y="..tostring(p.y)..", z="..tostring(p.z).."},},"
    local t = '["'..o.getGUID()..'"]={p={x='..tostring(p.x)..", y="..tostring(p.y)..", z="..tostring(p.z).."},},"
    log(t)
    s = s .. t .. '\n'
  end
  if s ~= "" then
    Notes.setNotes(s)
  end
end

require("tts-bosl/Constants")
require("tts-lib/utils")
