--[[ ********************************************************************************
  The Bridges of Shragi-La (2003)

	BGG URL: https://boardgamegeek.com/boardgame/8190/bridges-shangri-la
	Designer: Leo Colovini
	Publishers:
			KOSMOS
			999 Games
			Ãœberplay

	Mod by David Veach (2023)

	TODO: Bugfixes, ideas and such
	-- WARN: Remove UI stored state for destroyed objects (bridges) to prevent replay warnings on game reload.
	-- OCD: separate table of tile positions from GUIDs, take/replace tiles in top down order (indexed table of positions), build in setup

******************************************************************************** ]]

env = {}
env.test = {}
env.test.trace = true
env.test.debug = true
env.test.in_dev = false
env.test.force_fresh_save = false
env.test.hide_start_panel = false
-- env.test.test_players = {"Blue","Yellow","Red","Purple"}
-- env.test.test_players = {"Blue","Red","Purple"}

GD = {}

--[[ *****************************
Load function
********************************]]
function onLoad(saved_data)
	if env.test.trace then log("onLoad()") end
	if env.test.force_fresh_save then saved_data = "" end
	--initialize objects
	local board = getObjectFromGUID(C.board_guid)
	if not(env.test.in_dev) then
		board.interactable = false
		for g,_ in pairs(C.markers) do
			getObjectFromGUID(g).interactable = false
		end
		for g,_ in pairs(C.tiles) do
			local tile = getObjectFromGUID(g)
			if tile then tile.interactable = false end
		end
		getObjectFromGUID(C.trash_guid).interactable = false
	end

	if (saved_data ~= "") then
    log("onLoad(): load with saved data")
    local restore_data = JSON.decode(saved_data)
		--if env.test.debug then log(restore_data) end
    GD = restore_data
    restoreGameState()
  else
		log("onLoad(): load with fresh state")
		onLoadInit()
	end
end

--[[ *****************************
Save game state
********************************]]
function onSave()
  local saved_data = JSON.encode(GD)
  if env.test.force_fresh_save then
    saved_data = ""
  end
  return saved_data
end

--[[ *****************************
Restore the game state.
********************************]]
function restoreGameState()
	if env.test.trace then log("restoreGameState()") end
	--[[ replay saved global UI setAttributes --]]
	if env.test.debug then log("replay saved global UI setAttributes") end
  for key,value in pairs(GD.states.global_UI) do
    local id = Split(key, '|')[1]
    local field = Split(key, '|')[2]
    local success = UI.setAttribute(id, field, value)
    if not(success) and env.test.debug then
      log("ERROR: restoreGameState(): Unable to setAttribute for global UI"..field.." on id "..id.." to "..tostring(value))
    end
  end
	--[[ replay saved board UI setAttributes --]]
  if env.test.debug then log("replay saved board UI setAttributes") end
  local board = getObjectFromGUID(C.board_guid)
  for key,value in pairs(GD.states.board_UI) do
    local id = Split(key, '|')[1]
    local field = Split(key, '|')[2]
		local success = board.UI.setAttribute(id, field, value)
    if not(success) and env.test.debug then
      log("ERROR: restoreGameState(): Unable to setAttribute for board UI"..field.." on id "..id.." to "..tostring(value))
    end
  end
	for key,value in pairs(GD.states.bridge_UI) do
		local guid = Split(key, '|')[1]
		local bridge = getObjectFromGUID(guid)
		if bridge then
			local id = Split(key, '|')[2]
	    local field = Split(key, '|')[3]
			local success = bridge.UI.setAttribute(id, field, value)
	    if not(success) and env.test.debug then
	      log("ERROR: restoreGameState(): Unable to setAttribute for bridge:"..guid.." UI "..field.." on id "..id.." to "..tostring(value))
	    end
		else
			--TODO: alieviate the need for this by removing UI states when trashing a bridge
			if env.test.debug then log("WARN: restoreGameState(): Skipping UI replay on destroyed bridge "..tostring(guid)) end
		end
	end
end

--[[ ******************************
Wrapper function for global UI attributes.
Saves attribute update to be replayed on restore.
*********************************]]
function UI_setAttribute(id, field, value)
  if env.test.trace2 then log("UI_setAttribute()") end
  assert(type(id) == "string", "UI_setAttribute(): id must be a string")
  assert(type(field) == "string", "UI_setAttribute(): field must be a string")
  assert(value or value==false, "UI_setAttribute(): value missing")
  GD.states.global_UI[id.."|"..field] = value
  UI.setAttribute(id, field, value)
end

--[[ ******************************
Wrapper function for saving board UI attributes.
Saves attribute update to be replayed on restore.
*********************************]]
function board_UI_setAttribute(id, field, value)
	if env.test.trace2 then log("board_UI_setAttribute()") end
	assert(type(id) == "string", "board_UI_setAttribute(): id must be a string")
	assert(type(field) == "string", "board_UI_setAttribute(): field must be a string")
	assert(value or value==false, "board_UI_setAttribute(): value missing")
	GD.states.board_UI[id.."|"..field] = value
	return getObjectFromGUID(C.board_guid).UI.setAttribute(id, field, value)
end

--[[ ******************************
Wrapper function for saving bridge UI attributes.
Saves attribute update to be replayed on restore.
Also saves bridge object guid to apply update to.
*********************************]]
function bridge_UI_setAttribute(guid, id, field, value)
	if env.test.trace2 then log("bridge_UI_setAttribute()") end
	assert(type(guid) == "string", "bridge_UI_setAttribute(): guid must be a string")
	assert(type(id) == "string", "bridge_UI_setAttribute(): id must be a string")
	assert(type(field) == "string", "bridge_UI_setAttribute(): field must be a string")
	assert(value or value==false, "bridge_UI_setAttribute(): value missing")
	GD.states.bridge_UI[guid.."|"..id.."|"..field] = value
	return getObjectFromGUID(guid).UI.setAttribute(id, field, value)
end

--[[ *****************************
Initial load setup.
********************************]]
function onLoadInit()
	if env.test.trace then log("onLoadInit()") end
	GD.game = {}
	GD.env = {}
	GD.states = {}
	GD.states.global_UI = {}
	GD.states.board_UI = {}
	GD.states.bridge_UI = {}
	GD.bridges = {}
	for _,bridge in ipairs(C.bridges) do
		GD.bridges[bridge.guid]=bridge				--HACK: should I refactor this or C.bridges ???
	end
  GD.cities = simpleDeepCopy(C.cities)
	GD.game.player_order = {}
	GD.env.use_suggested_placement = false
	GD.env.verbose = true
	GD.env.use_student_decals = true
	GD.env.alt_click_for_journey_preview = false
	GD.game.played_tiles = 0
	GD.game.masters_placed = 0
	GD.game.journey_completed = false
	GD.game.closed_cities = 0
	GD.game.used_markers = {}
	GD.game.undo = {}
	GD.game.stage = "init"
	GD.game.current_player = ""
	UI_setAttribute("journeyAckPanel","visibility","Pink")
	UI_setAttribute("journeyAckPanel","active","true")
	UI_setAttribute("opt_use_suggested_setup", "isOn", GD.env.use_suggested_placement)
	local s = "Use the rules suggested opening masaters tile placement."
	s = s .."\nRecommend enabling this for new players."
	UI_setAttribute("opt_use_suggested_setup", "tooltip", s)
	UI_setAttribute("opt_verbose", "isOn", GD.env.verbose)
	s = "Use verbose game logging and notifications."
	UI_setAttribute("opt_verbose", "tooltip", s)
	UI_setAttribute("opt_alt_mouse_btn", "isOn", GD.env.alt_click_for_journey_preview)
	s = "If enabled, only display Student Journey preview if bridge is right-clicked."
	s = s.."\nIf disabled, preview is shown on left-click and right-click will bypass preview."
	s = s.."\nLeave disabled for new players."
	UI_setAttribute("opt_alt_mouse_btn", "tooltip", s)
	if not(env.test.hide_start_panel) then
		UI_setAttribute("startPanel","active","true")
	end
end

--[[ *****************************
  UI handler for initial game setup options.
  ********************************]]
function handleOptionsUIBtn(player, value, id)
  if env.test.trace then log("handleOptionsUIBtn(): id: "..tostring(id)..", value: "..tostring(value)) end
  local setting = (value == 'True')
  UI_setAttribute(id, "isOn", setting)
  if id == "opt_use_suggested_setup" then
    GD.env.use_suggested_placement = setting
		UI_setAttribute("opt_use_suggested_setup","isOn",setting)
  elseif id == "opt_verbose" then
    GD.env.verbose = setting
		UI_setAttribute("opt_verbose","isOn",setting)
	elseif id == "opt_alt_mouse_btn" then
		GD.env.alt_click_for_journey_preview = setting
		UI_setAttribute("opt_alt_mouse_btn","isOn",setting)
	else
		log("WARN: handleOptionsBtn(): Unknown id: "..tostring(id))
  end
end

--[[ *****************************
Button handler for start game dialog.
********************************]]
function startGameBtn(player, btn, id)
	if env.test.trace then log("startGameBtn(): "..player.color) end
	startGame()
end

--[[ *****************************
Start the game after all players are seated.
********************************]]
function startGame()
	if env.test.trace then log("startGame()") end
	--Determine number of players
	local seated = getSeatedPlayers()
	if env.test.test_players then seated = env.test.test_players end
	GD.game.players = {}
	for _,pcol in ipairs(C.player_colors) do
		if contains(seated, pcol) then
			table.insert(GD.game.player_order, pcol)
			GD.game.players[pcol] = {
				unplayed_tiles = {},
				played_tiles = {},
			}
		end
	end
	local player_count = #GD.game.player_order
	if player_count < 3 or player_count > 4 then	--TODO: is > 4 possible?
		broadcastToAll("Sorry 3 or 4 players needed to play this game.")
		return
	end
	UI_setAttribute("startPanel","active","false")
	for g,td in pairs(C.tiles) do
		if contains(GD.game.player_order, td.c) then
			GD.game.players[td.c].unplayed_tiles[g] = td.t
		else
			getObjectFromGUID(g).destruct()
		end
	end
	if player_count == 3 then
		closeCity(3)
		log("out probe")
		local trash = getObjectFromGUID(C.trash_guid)
		for g,bd in pairs(GD.bridges) do
			if bd.id == 2 or bd.id == 8 or bd.id == 9 then
				if env.test.debug then log("Trashing bridge "..g.." for 3 player game") end
				trash.putObject(getObjectFromGUID(g))
				bd.intact = false
			end
		end
		for _,pcol in ipairs(C.player_colors) do
			UI_setAttribute(pcol.."_statusRow","active",contains(GD.game.player_order, pcol))
		end
		UI_setAttribute("statusPanel","height","330")
		UI_setAttribute("statusInnerPanel","height","310")
	end
	GD.game.current_player = math.random(1,#GD.game.player_order)
	local current = GD.game.player_order[GD.game.current_player]
	if env.test.debug then log("Current player is "..current) end
	if GD.env.use_suggested_placement then
		suggestedPlacement(player_count)
		GD.game.stage = "play"
		UI_setAttribute("statusTitle","text","Game Play")
		for g,td in pairs(C.tiles) do
			local tile = getObjectFromGUID(g)
			if tile then tile.interactable = true end
		end
		broadcastToAll("Begin game with suggested initial placement")
	else
		GD.game.stage = "placement"
		UI_setAttribute("statusTitle","text","Initial Placement")
		for g,td in pairs(C.tiles) do
			local tile = getObjectFromGUID(g)
			if tile then tile.interactable = td.i end
		end
		broadcastToAll("Place intial Master Tiles")
	end
	updateScores()
	UI_setAttribute("statusPanel","active","true")
	setActivePlayer(false)
end

--[[ *****************************
Setup the game for suggested initial tile placement based on player count.
Includes closing and blocking off City 3 if 3-player game.
********************************]]
function suggestedPlacement(player_count)
	if env.test.trace then log("suggestedPlacement() player count = "..tostring(player_count)) end
	local suggested
	if player_count == 3 then suggested = C.suggested_3_player_placement
	elseif player_count == 4 then suggested = C.suggested_4_player_placement
	else
		log("ERROR: suggestedPlacement(): Invalid player count")
		return
	end
	for g,td in pairs(C.tiles) do
		if td.i then
			local index = indexOf(GD.game.player_order, td.c)
			if index > 0 then
				local city_id = suggested[index][td.t]
				locateTile(getObjectFromGUID(g), city_id)
			end
		end
	end
	updateCityStrengths()
	updateScores()
end

--[[ *****************************
Sets the active player.  Advance param defaults to true.
********************************]]
function setActivePlayer(advance)
	if advance == nil then advance = true end
	local board = getObjectFromGUID(C.board_guid)
	local current = GD.game.player_order[GD.game.current_player]
	local old = current
	if advance then
		board_UI_setAttribute(current.."PlayerPanel", "active", "false")
		GD.game.current_player = GD.game.current_player + 1
		if GD.game.current_player > #GD.game.player_order then GD.game.current_player = 1 end --wrap
		current = GD.game.player_order[GD.game.current_player]
		if env.test.debug then log("Current player is now "..current) end
		if env.test.test_players then
			Player[old].changeColor(current)
		end
	end
	for _,pcol in ipairs(GD.game.player_order) do
		board_UI_setAttribute(pcol.."UndoPanel","active","false")
		board_UI_setAttribute(pcol.."DonePanel","active",GD.game.stage=="play")
		board_UI_setAttribute(pcol.."JourneyPanel","active",GD.game.stage=="play")
		board_UI_setAttribute(pcol.."PlacementPanel","active",GD.game.stage=="placement")
		board_UI_setAttribute(pcol.."PlayerPanel","active",pcol == current)
	end
	GD.game.undo = {}
	GD.game.journey = {}
	GD.game.played_tiles = 0
	if GD.game.stage == "play" then GD.game.masters_placed = 0 end
	GD.game.journey_completed = false
	UI_setAttribute("statusActivePlayer","text",current)
	UI_setAttribute("statusActivePlayer","color",current)
	if GD.game.stage == "placement" then
		UI_setAttribute("statusActiveAction","text","Place a Master")
	else
		UI_setAttribute("statusActiveAction","text","Choose an action")
	end
end

--[[ *****************************
Locate ID in the network of nearest city to dropped tile position.  Returns -1 if not found.
TODO: consider finding nearest valid city for tile placement.  Currently only closest of any city.
********************************]]
function findNearestCity(pos)
  assert(pos, "ERROR: findNearestCity(): missing parameter 'pos'")
  if env.test.trace then log("findNearestCity()") end
  local nearest = nil
  local shortest_dist = nil
  for _,city in ipairs(GD.cities) do
    local dist = Vector.sqrDistance(pos, Vector(city.pos))
    if nearest == nil or dist < shortest_dist then
      shortest_dist = dist
      nearest = city
    end
  end
  if nearest then
    return nearest.id
  else
    if env.test.debug then log("ERROR: findNearestCity(): failed to locate a city.") end
    return -1
  end
end

--[[ *****************************
Handle dropping a tile.
********************************]]
function onObjectDrop(pcol, obj)
  if env.test.trace then log("onObjectDrop(): "..pcol.." dropped "..obj.getGUID()) end
  --ignore non-tile objects
  if obj.tag ~= "Tile" then return end
  --dropped off board
  local board = getObjectFromGUID(C.board_guid)
  local center = board.getBounds()["center"]
  local size = board.getBounds()["size"]
  local pos = obj.getPosition()
	--return tile if dropped off board
	if pos.x > center.x + (size.x/2) or pos.x < center.x - (size.x/2) then returnTile(obj.getGUID()); return end
  if pos.z > center.z + (size.z/2) or pos.z < center.z - (size.z/2) then returnTile(obj.getGUID()); return end
	--Locate nearest city
  local city_id = findNearestCity(obj.getPosition())
  assert(city_id > 0,"ERROR: onObjectDrop(): Could not locate nearest city")
  local city = GD.cities[city_id]
	if city.closed then
		if GD.env.verbose then broadcastToColor("That city is closed to new students", pcol) end
		returnTile(obj.getGUID())
		return
	end
	if city.tiles[obj.getGUID()] ~= nil then
    if env.test.debug then log("ignoring tile drop in same city") end
		return
	end
	--disallow dropping more than one tile
	local set = Player[pcol].getSelectedObjects()
	if #set > 1 then
		if env.test.debug then log(pcol.." cannot place multiple tiles on the board at once") end
		if GD.env.verbose then broadcastToColor("Cannot place multiple tiles on the board at once", pcol) end
		returnTile(obj.getGUID())
		return
	end
	placeTile(obj, city_id, pcol)
end

--[[ *****************************
Place a tile in a city and and update network info, UI etc.
Perform checks on validity.
********************************]]
function placeTile(tile, city_id, pcol)
	if env.test.trace then log("placeTile(): "..tostring(tile)..", city "..tostring(city_id)..", player "..tostring(pcol)) end
	if pcol ~= GD.game.player_order[GD.game.current_player] then
		returnTile(tile.getGUID())
		return
	end
	--Disallow if game end
	if GD.game.stage == "end" then
		if env.test.debug then log(pcol.." cannot place students after game end") end
		returnTile(tile.getGUID())
		return
	end
	--Disallow if student journey completed
	if GD.game.journey_completed then
		if env.test.debug then log(pcol.." cannot place students after a journey") end
		if GD.env.verbose then broadcastToColor("Cannot place students after a journey", pcol) end
		returnTile(tile.getGUID())
		return
	end
	--Get tile metadata
	local type = C.tiles[tile.getGUID()].t
	assert(type,"ERROR: onObjectDrop(): failed to locate type for "..tile.getGUID())
	local color = C.tiles[tile.getGUID()].c
	assert(color,"ERROR: onObjectDrop(): failed to locate color for "..tile.getGUID())
	if env.test.debug then log("Tile type:"..type..", color:"..color..", Snap:"..tostring(snap_back)) end
	--disallow active player placing other's tiles
	if pcol ~= color then
		if env.test.debug then log(pcol.." cannot place other's tiles") end
		if GD.env.verbose then broadcastToColor("Cannot place other player's tiles", pcol) end
		returnTile(tile.getGUID())
		return
	end
	local city = GD.cities[city_id]
	-- ////////////////////////////////////
	-- *** TILE DROP DURING NORMAL PLAY ***
	-- ////////////////////////////////////
	if GD.game.stage == "play" then
		--place only up to 2 students per turn
		if GD.game.stage == "play" and GD.game.played_tiles == 2 then
			if GD.env.verbose then broadcastToColor("Play no more than 2 Students a turn", pcol) end
			returnTile(tile.getGUID())
			return
		end
		local count = 0
		for tg,_ in pairs(city.tiles) do
			local tile_data = C.tiles[tg]
			if tile_data.t == type and tile_data.c ~= color then
				if env.test.debug then log("another player already played a "..tile.getName().." here") end
				if GD.env.verbose then broadcastToColor("Another player already played a "..tile.getName().." here", pcol) end
				returnTile(tile.getGUID())
				return
			elseif tile_data.t == type and tile_data.c == color then
				count = count + 1
				if count >= 2 then
					if env.test.debug then log("already a "..tile.getName().." student here, cannot play another") end
					if GD.env.verbose then broadcastToColor("Already a "..tile.getName().." student here, cannot play another", pcol) end
					returnTile(tile.getGUID())
					return
				end
			end
		end
		-- Place new Master during game play
		if count == 0 then
			if GD.game.played_tiles > 0 then
				if GD.env.verbose then broadcastToColor("Only one new master per turn allowed", pcol) end
				returnTile(tile.getGUID())
				return
			end
			-- Allow master if at least one other tile in city matching color
			local valid = false
			for g,tile_data in pairs(GD.cities[city_id].tiles) do
				if tile_data.c == color then valid = true; break end
			end
			if not(valid) then
				if GD.env.verbose then broadcastToColor("One other Master of same color in city requrired to place a new master", pcol) end
				returnTile(tile.getGUID())
				return
			end
			if env.test.debug then log("valid master for "..tile.getName()) end
			if GD.env.verbose then printToAll(pcol.." places "..tile.getName().." Master in city "..tostring(city.id)) end
			GD.game.masters_placed = GD.game.masters_placed + 1
		else
			if GD.game.masters_placed > 0 then
				if GD.env.verbose then broadcastToColor("Cannot place a Student after placing a Master", pcol) end
				returnTile(tile.getGUID())
				return
			end
			if env.test.debug then log("valid student for "..tile.getName()) end
			if GD.env.verbose then printToAll(pcol.." places "..tile.getName().." Student in city "..tostring(city.id)) end
		end
	-- //////////////////////////////////////////
	-- *** TILE DROP DURING INITIAL PLACEMENT ***
	-- //////////////////////////////////////////
	elseif GD.game.stage == "placement" then
		--place only one master per turn
		if GD.game.played_tiles == 1 then
			if GD.env.verbose then broadcastToColor("Place only 1 Master a turn", pcol) end
			returnTile(tile.getGUID())
			return
		end
		-- no more than 3 tiles per city total (2 for 3 player)
		local pnum = #GD.game.player_order
		if (pnum == 3 and sizeOf(city.tiles) >= 2) or (pnum == 4 and sizeOf(city.tiles) >= 3) then
			if env.test.debug then log("Maximum masters placed in city "..tostring(city.id)) end
			if GD.env.verbose then broadcastToColor("Maximum masters placed in city", pcol) end
			returnTile(tile.getGUID())
			return
		end
		-- cannot play same master as another color
		local count = 0
		for tg,_ in pairs(city.tiles) do
			local tile_data = C.tiles[tg]
			if tile_data.t == type and tile_data.c ~= color then
				if env.test.debug then log("Another player already played a "..tile.getName().." here") end
				if GD.env.verbose then broadcastToColor("Another player already played a "..tile.getName().." here", pcol) end
				returnTile(tile.getGUID())
				return
			elseif tile_data.c == color then
				count = count + 1
			end
		end
		-- no more than 2 tiles of same color in city (1 for 3 player)
		if (pnum == 3 and count >= 1) or (pnum == 4 and count >= 2) then
			if env.test.debug then log("Maximum masters placed in city for player color "..pcol) end
			if GD.env.verbose then broadcastToColor("Maximum masters placed in city for player color "..pcol, pcol) end
			returnTile(tile.getGUID())
			return
		end
		if env.test.debug then log(pcol.." places "..tile.getName().." master in city "..tostring(city.id)) end
		if GD.env.verbose then printToAll(pcol.." places "..tile.getName().." Master in city "..tostring(city.id)) end
		GD.game.masters_placed = GD.game.masters_placed + 1
	end
	-- Assign tile to city and update Undo & UI stuffs
	locateTile(tile, city.id)
	UI_setAttribute("journeyAckPanel","visibility","Pink") --just in case player had started a journey
	local undo = { action = "tile_drop", guid = tile.getGUID(), }
	table.insert(GD.game.undo, undo)
	GD.game.played_tiles = GD.game.played_tiles + 1
	if GD.game.stage == "placement" then
		local board = getObjectFromGUID(C.board_guid)
		board_UI_setAttribute(pcol.."UndoPanel","active","true")
		board_UI_setAttribute(pcol.."DonePanel","active","true")
		board_UI_setAttribute(pcol.."PlacementPanel","active","false")
	elseif GD.game.stage == "play" then
		disableBridgeButtons() --Just in case bridges were enabled
		local board = getObjectFromGUID(C.board_guid)
		board_UI_setAttribute(pcol.."JourneyPanel","active","false")
		board_UI_setAttribute(pcol.."UndoPanel","active","true")
		board_UI_setAttribute(pcol.."DonePanel","active","true")
		UI_setAttribute("statusActiveAction","text","Place Students "..tostring(GD.game.played_tiles).."/2")
	end
	updateCityStrengths()
	updateScores()
end

--[[ *****************************
Place a student (if avaialble) when player clicks a master tile
********************************]]
function masterClick(tile, pcol, alt_click)
	if env.test.trace then log("masterClick():"..pcol.." clicked "..tile.getName()..":"..tile.getGUID()..", alt="..tostring(alt_click)) end
	if pcol ~= C.tiles[tile.getGUID()].c then return end --ignore clicks on other player's master tiles
	local master_type = C.tiles[tile.getGUID()].t
	local city_id = -1
	for id,city in ipairs(GD.cities) do
		if city.tiles[tile.getGUID()] ~= nil then city_id = id; break end
	end
	assert(city_id > 0,"ERROR: masterClick(): Master not found in city network.")
	for g,type in pairs(GD.game.players[pcol].unplayed_tiles) do
		if type == master_type then
			placeTile(getObjectFromGUID(g), city_id, pcol)
			return
		end
	end
	broadcastToColor("You have no more "..master_type.." students to place", pcol)
end

--[[ *****************************
Locate a tile in the appropriate spot in a city.
Update city tile data and set state on tile according to rank.
********************************]]
function locateTile(tile, city_id)
	if env.test.trace then log("locateTile() "..tostring(tile)..", city id "..tostring(city_id)) end
	local cpos = GD.cities[city_id].pos
	local type = C.tiles[tile.getGUID()].t
	local color = C.tiles[tile.getGUID()].c
  local dx, dz
  if type == "Rain" then dx,dz = -0.5,1
  elseif type == "Astro" then dx,dz = 0.5,1
  elseif type == "Dragon" then dx,dz = -1,0
  elseif type == "Priest" then dx,dz = 0,0
  elseif type == "Yeti" then dx,dz = 1,0
  elseif type == "Fire" then dx,dz = -0.5,-1
  elseif type == "Healer" then dx,dz = 0.5,-1
  else
    log("ERROR: Tile "..tile.getGUID().." has no matching tag")
    return
  end
	tile.setLock(false)
	tile.setVelocity(Vector(0,0,0))
  tile.setPosition(Vector(cpos.x + dx, 2, cpos.z + dz))
	local rank = "master"
	for _,td in pairs(GD.cities[city_id].tiles) do
		if td.t == type and td.c == color then
			rank = "student"
			break
		end
	end
	if rank == "master" then
		if env.test.debug then log("Creating button on "..tile.getName()..": "..tile.getGUID()) end
		tile.createButton(C.masterButtonParams)
		tile.setDecals({})
	else
		tile.clearButtons()
		if GD.env.use_student_decals then addDecal(tile.getGUID()) end
	end
	GD.cities[city_id].tiles[tile.getGUID()] = {t=type, c=color, r=rank}
	GD.game.players[color].played_tiles[tile.getGUID()] = type
	GD.game.players[color].unplayed_tiles[tile.getGUID()] = nil
  Wait.condition(function() tile.setLock(true) end, function() return tile.isDestroyed() or tile.resting end, 5)
end

--[[ *****************************
Update strength displays for cities.
********************************]]
function updateCityStrengths()
	if env.test.trace then log("updateCityStrengths()") end
	local board = getObjectFromGUID(C.board_guid)
	for i=1,13 do
		board_UI_setAttribute("cityText_"..tostring(i),"text",tostring(sizeOf(GD.cities[i].tiles)))
	end
end

--[[ *****************************
Update player scores for masters in cities.
********************************]]
function updateScores()
  if env.test.trace then log("updateScores()") end
  --For each player color, for each city, sum up all masters and cities with at least one master
	GD.game.scores = {}
	for _,pcol in ipairs(GD.game.player_order) do
		GD.game.scores[pcol]={cities=0,masters=0}
	end
	for pcol,score in pairs(GD.game.scores) do
		for _,city in ipairs(GD.cities) do
			local found_master = false
			local masters = 0
			for g,td in pairs(city.tiles) do
				if td.c == pcol then
					if td.r == "master" then
						if not(found_master) then
							score.cities = score.cities + 1
							found_master = true
						end
						masters = masters + 1
					end
				end
			end
			score.masters = score.masters + masters
		end
	end
	-- if env.test.debug then log(GD.game.scores) end
	for pcol,score in pairs(GD.game.scores) do
		UI_setAttribute(pcol.."_statusCities","text",tostring(score.cities))
		UI_setAttribute(pcol.."_statusMasters","text",tostring(score.masters))
	end
end

--[[ *****************************
Process any undo actions.
********************************]]
function undo(pcol)
  if env.test.trace then log("undo(): "..pcol) end
	local needs_update = true
  for _,undo in ipairs(GD.game.undo) do
    if undo.action == "tile_drop" then
			returnTile(undo.guid)
			for _,city in ipairs(GD.cities) do
				if city.tiles[undo.guid] ~= nil then city.tiles[undo.guid] = nil end
			end
    elseif undo.action == "select-journey" then
			disableBridgeButtons()
		elseif undo.action == "journey" then
			GD.game.journey_completed = false
			--return markers (if any)
			if undo.markers ~= nil then
				if env.test.debug then log("Undo marker placement") end
				for _,undo_data in ipairs(undo.markers) do
					local marker = getObjectFromGUID(undo_data.guid)
					assert(marker,"ERROR: undo(): No obj for marker guid "..tostring(undo_data.guid))
					marker.setPosition(C.markers[marker.getGUID()].p)
					table.remove(GD.game.used_markers,indexOf(GD.game.used_markers, undo_data.guid))
					--open city back up
					GD.game.closed_cities = GD.game.closed_cities - 1
					GD.cities[undo_data.city_id].closed = false
					for g,td in pairs(GD.cities[undo_data.city_id].tiles) do
						if td.t == "master" then getObjectFromGUID(g).addButton(C.masterButtonParams) end
					end
				end
			end
			--replace bridge from trash bag
			if undo.bridge ~= nil then
				if env.test.debug then log("Undo trash bridge") end
				local params = {
					guid = undo.bridge.guid,
					position = undo.bridge.position,
					rotation = undo.bridge.rotation,
					callback_function = function(obj)
						Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 3)
					end,
					}
				local trash = getObjectFromGUID(C.trash_guid)
				trash.takeObject(params)
				GD.bridges[undo.bridge.guid].intact = true
			else
				log("ERROR: undo(): No bridge data for journey undo")
			end
			--return students from destination to origin (if any)
			if undo.placed_students ~= nil then
				if env.test.debug then log("Undo students placed in destination") end
				for _,g in ipairs(undo.placed_students) do
					local tile = getObjectFromGUID(g)
					locateTile(tile, undo.orig_id)
					-- if GD.env.use_student_decals then addDecal(g) end
					GD.cities[undo.dest_id].tiles[g] = nil
				end
			end
			--return displaced masters to destination (if any)
			Wait.frames(function()
				if undo.displaced_masters ~= nil then
					if env.test.debug then log("Undo masters displaced from destination") end
					for _,g in ipairs(undo.displaced_masters) do
						local tile = getObjectFromGUID(g)
						locateTile(tile, undo.dest_id)
					end
				end
			end, 30)
			--return displaced students to destination (if any)
			Wait.frames(function()
				if undo.displaced_students ~= nil then
					if env.test.debug then log("Undo students displaced from destination") end
					for _,g in ipairs(undo.displaced_students) do
						local tile = getObjectFromGUID(g)
						locateTile(tile, undo.dest_id)
						-- if GD.env.use_student_decals then addDecal(g) end
					end
				end
			end, 60)
			--return displaced students to origin (if any)
			Wait.frames(function()
				if undo.displaced_origin_students ~= nil then
					if env.test.debug then log("Undo students displaced from origin") end
					for _,g in ipairs(undo.displaced_origin_students) do
						local tile = getObjectFromGUID(g)
						locateTile(tile, undo.orig_id)
						-- if GD.env.use_student_decals then addDecal(g) end
					end
				end
				updateCityStrengths()
				updateScores()
				needs_update = false
			end, 90)
		elseif undo.action == "close_city" then
			for g,td in pairs(GD.cities[undo.id].tiles) do
				local tile = getObjectFromGUID(g)
				if tile then
					tile.createButton(C.masterButtonParams)
				else
					log("ERROR: undo(): close_city, Unable to add button to master tile "..tostring(g))
				end
			end
    else
      log("ERROR: undo() Unknown action")
    end
  end
	GD.game.undo = {}
	GD.game.played_tiles = 0
	if GD.game.stage == "play" then
		UI_setAttribute("statusActiveAction","text","Choose an action")
		GD.game.masters_placed = 0
	elseif GD.game.stage == "placement" then
		UI_setAttribute("statusActiveAction","text","Place a Master")
		GD.game.masters_placed = GD.game.masters_placed - 1
	end
	local board = getObjectFromGUID(C.board_guid)
	board_UI_setAttribute(pcol.."UndoPanel","active","false")
	board_UI_setAttribute(pcol.."JourneyPanel","active",GD.game.stage=="play")
	board_UI_setAttribute(pcol.."PlacementPanel","active",GD.game.stage=="placement")
	board_UI_setAttribute(pcol.."DonePanel","active",GD.game.stage=="play")
	if needs_update then
		--HACK: had to duplicate the updates in last journey undo due to the delay.
		updateCityStrengths()
		updateScores()
	end
end

--[[ *****************************
Setup a student journey for the selected bridge and direction.
Called from a bridge object when player clicks a displayed arrow.
params:
	guid:	bridge GUID
	pcol:	player.color
	id:		arrow button id ("upArrow" or "downArrow")
	button: "-1" for primary mouse button, "-2" or "-3" for right, middle buttons respectively
********************************]]
function startStudentJourney(params)
	if env.test.trace then log("startStudentJourney()") end
	if env.test.debug then log(params) end
	log(type(params.button))
	local show_preview = true
	if GD.env.alt_click_for_journey_preview then
		if params.button == "-1" then
			if env.test.debug then log("Bypassing preview") end
			show_preview = false
		end
	else
		if params.button ~= "-1" then
			if env.test.debug then log("Bypassing preview") end
			show_preview = false
		end
	end
	GD.game.journey = {}
	local journey = GD.game.journey
	journey.player_color = params.pcol
	journey.bridge_guid = params.guid
	journey.bridge_id = GD.bridges[journey.bridge_guid].id
	journey.origin = {}
	journey.dest = {}
	--"upArrow" is moving from smaller number city to bigger.  "downArrow" is moving from bigger to smaller.
	local bridge = GD.bridges[journey.bridge_guid]
	if params.id == "upArrow" then
		journey.origin.city = GD.cities[bridge.cities[1]]
		journey.dest.city = GD.cities[bridge.cities[2]]
	elseif params.id == "downArrow" then
		journey.origin.city = GD.cities[bridge.cities[2]]
		journey.dest.city = GD.cities[bridge.cities[1]]
	else
		log("ERROR: startStudentJourney(): Unknown arrow button id")
		return
	end
	--setup journey tile data
	journey.origin.masters = {}
	journey.origin.students = {}
	journey.origin.strength = sizeOf(journey.origin.city.tiles)
	for g,td in pairs(journey.origin.city.tiles) do
		if td.r == "master" then
			journey.origin.masters[td.t]={g=g, c=td.c,}
		else
			journey.origin.students[td.t]={g=g, c=td.c,}
		end
	end
	journey.dest.masters = {}
	journey.dest.students = {}
	journey.dest.additions = {}
	journey.dest.strength = sizeOf(journey.dest.city.tiles)
	for g,td in pairs(journey.dest.city.tiles) do
		if td.r == "master" then
			journey.dest.masters[td.t]={g=g, c=td.c,}
		else
			journey.dest.students[td.t]={g=g, c=td.c,}
		end
	end
	--determine city winner
	journey.origin_wins = false
	if journey.origin.strength > journey.dest.strength then
		journey.origin_wins = true
	elseif (journey.origin.strength == journey.dest.strength) and (sizeOf(journey.origin.masters) > sizeOf(journey.dest.masters)) then
		journey.origin_wins = true
	end
	--setup tile actions
	for type,td in pairs(journey.origin.students) do
		if journey.origin_wins then
			if journey.dest.students[type] ~= nil and journey.dest.students[type].c == td.c then
				journey.origin.students[type].action = "return"
			elseif journey.dest.masters[type] ~= nil and journey.dest.masters[type].c == td.c then
				journey.origin.students[type].action = "place"
				journey.dest.additions[type] = "student"
			elseif journey.dest.masters[type] ~= nil and journey.dest.masters[type].c ~= td.c then
				journey.origin.students[type].action = "place"
				journey.dest.masters[type].action = "return"
				if journey.dest.students[type] ~= nil then
					journey.dest.students[type].action = "return"
				end
			else
				journey.origin.students[type].action = "place"
				journey.dest.additions[type] = "master"
			end
		else
			if journey.dest.masters[type] == nil then
				journey.origin.students[type].action = "place"
			else
				journey.origin.students[type].action = "return"
			end
		end
	end
	--determine if city closed
	journey.origin.closed = true
	for _,neighbor in ipairs(journey.origin.city.neighbors) do
		if neighbor.bridge ~= journey.bridge_id then
			if GD.bridges[C.bridges[neighbor.bridge].guid].intact then		--TODO: refactor bridge meta data to avoid this lookup
				journey.origin.closed = false
				break
			end
		end
	end
	journey.dest.closed = true
	for _,neighbor in ipairs(journey.dest.city.neighbors) do
		if neighbor.bridge ~= journey.bridge_id then
			if GD.bridges[C.bridges[neighbor.bridge].guid].intact then		--TODO: refactor bridge meta data to avoid this lookup
				journey.dest.closed = false
				break
			end
		end
	end
	if env.test.debug then log(journey) end
	if show_preview then
		UI_setAttribute("js_origin_city_label","text","Origin City #"..tostring(journey.origin.city.id))
		UI_setAttribute("js_origin_city_strength","text","Strength = "..tostring(journey.origin.strength))
		UI_setAttribute("js_dest_city_label","text","Destination City #"..tostring(journey.dest.city.id))
		UI_setAttribute("js_dest_city_strength","text","Strength = "..tostring(journey.dest.strength))
		UI_setAttribute("sj_origin_closed_marker","active",journey.origin.closed)
		UI_setAttribute("sj_dest_closed_marker","active",journey.dest.closed)
		for _,type in ipairs(C.tile_types) do
			--set display defaults for tile type
			UI_setAttribute("sj_origin_student_action_"..type,"active","false")
			UI_setAttribute("sj_origin_student_action_"..type,"image","")
			UI_setAttribute("sj_origin_student_action_"..type,"color","Grey")
			UI_setAttribute("sj_dest_student_action_"..type,"active","false")
			UI_setAttribute("sj_dest_student_action_"..type,"image","")
			UI_setAttribute("sj_dest_student_action_"..type,"color","Grey")
			UI_setAttribute("sj_dest_master_action_"..type,"active","false")
			UI_setAttribute("sj_dest_master_action_"..type,"image","")
			UI_setAttribute("sj_dest_master_action_"..type,"color","Grey")
			UI_setAttribute("sj_origin_master_"..type,"image","Grey-"..type)
			UI_setAttribute("sj_origin_student_"..type,"image","Grey-"..type)
			UI_setAttribute("sj_dest_master_"..type,"image","Grey-"..type)
			UI_setAttribute("sj_dest_student_"..type,"image","Grey-"..type)
			--display any origin tiles
			if journey.origin.masters[type] ~= nil then
				UI_setAttribute("sj_origin_master_"..type,"image",journey.origin.masters[type].c.."-"..type)
				if journey.origin.students[type] ~= nil then
					UI_setAttribute("sj_origin_student_"..type,"image",journey.origin.students[type].c.."-"..type)
					if journey.origin.students[type].action == "place" then
						UI_setAttribute("sj_origin_student_action_"..type,"image","Sprites/Icons/Arrow_Right")
						UI_setAttribute("sj_origin_student_action_"..type,"color","Yellow")
						UI_setAttribute("sj_origin_student_action_"..type,"active","true")
					elseif journey.origin.students[type].action == "return" then
						UI_setAttribute("sj_origin_student_action_"..type,"image","Sprites/Icons/Cancel")
						UI_setAttribute("sj_origin_student_action_"..type,"color","Red")
						UI_setAttribute("sj_origin_student_action_"..type,"active","true")
					end
				end
			end
			--display any destination tiles
			if journey.dest.masters[type] ~= nil then
				UI_setAttribute("sj_dest_master_"..type,"image",journey.dest.masters[type].c.."-"..type)
				if journey.dest.masters[type].action == "return" then
					UI_setAttribute("sj_dest_master_action_"..type,"image","Red-X-Green-Plus")
					UI_setAttribute("sj_dest_master_action_"..type,"active","true")
				end
				if journey.dest.students[type] ~= nil then
					UI_setAttribute("sj_dest_student_"..type,"image",journey.dest.students[type].c.."-"..type)
					if journey.dest.students[type].action == "return" then
						UI_setAttribute("sj_dest_student_action_"..type,"image","Sprites/Icons/Cancel")
						UI_setAttribute("sj_dest_student_action_"..type,"color","Red")
						UI_setAttribute("sj_dest_student_action_"..type,"active","true")
					end
				end
			end
			if journey.dest.additions[type] ~= nil then
				if journey.dest.additions[type] == "master" then
					UI_setAttribute("sj_dest_master_action_"..type,"image","3d-Green-Plus")
					UI_setAttribute("sj_dest_master_action_"..type,"active","true")
				else
					UI_setAttribute("sj_dest_student_action_"..type,"image","3d-Green-Plus")
					UI_setAttribute("sj_dest_student_action_"..type,"active","true")
				end
			end
		end
		UI_setAttribute("journeyAckPanel","visibility",params.pcol)
		board_UI_setAttribute(params.pcol.."UndoPanel","active","false")
	else
		disableBridgeButtons()
		board_UI_setAttribute(params.pcol.."DonePanel","active","true")
		board_UI_setAttribute(params.pcol.."UndoPanel","active","true")
		board_UI_setAttribute(params.pcol.."JourneyPanel","active","false")
		UI_setAttribute("journeyAckPanel","visibility","Pink")
		processJourney()
	end
end

--[[ *****************************
Process a student journey.
Called after player ok's the preview dialog.
********************************]]
function processJourney()
	if env.test.trace then log("processJourney()") end
	local journey = GD.game.journey
	assert(journey ~= nil and journey ~= {},"ERROR: processJourney(): No journey data")
	--ssetup new undo action
	local undo = {
		action = "journey",
		orig_id = journey.origin.city.id,
		dest_id = journey.dest.city.id,
		markers = {},
		bridge = nil,
		placed_students = {},
		displaced_masters = {},
		displaced_students = {},
		displaced_origin_students = {},
	}
	GD.game.undo = {undo}
	--process the journey data
	for type,tile_data in pairs(journey.dest.students) do
		if tile_data.action ~= nil and tile_data.action == "return" then
			returnTile(tile_data.g)
			journey.dest.city.tiles[tile_data.g] = nil
			table.insert(undo.displaced_students, tile_data.g)
		end
	end
	for type,tile_data in pairs(journey.dest.masters) do
		if tile_data.action ~= nil and tile_data.action == "return" then
			returnTile(tile_data.g)
			journey.dest.city.tiles[tile_data.g] = nil
			table.insert(undo.displaced_masters, tile_data.g)
		end
	end
	for type,tile_data in pairs(journey.origin.students) do
		if tile_data.action ~= nil and tile_data.action == "place" then
			local tile = getObjectFromGUID(tile_data.g)
			-- clearDecal(tile.getGUID())
			locateTile(tile, journey.dest.city.id)
			journey.origin.city.tiles[tile_data.g] = nil
			table.insert(undo.placed_students, tile.getGUID())
		elseif tile_data.action ~= nil and tile_data.action == "return" then
			returnTile(tile_data.g)
			journey.origin.city.tiles[tile_data.g] = nil
			table.insert(undo.displaced_origin_students, tile_data.g)
		end
	end
	--trash the bridge used
	local b = getObjectFromGUID(journey.bridge_guid)
	assert(b, "ERROR: studentJourney(): no bridge object for guid "..tostring(journey.bridge_guid))
	bridge_UI_setAttribute(journey.bridge_guid,"mainPanel","active","false")
	undo.bridge = {guid = journey.bridge_guid, position = b.getPosition(), rotation = b.getRotation(),}
	local trash = getObjectFromGUID(C.trash_guid)
	trash.putObject(b)
	GD.bridges[journey.bridge_guid].intact = false
	--mark any closed cities
	if journey.origin.closed then
		Wait.frames(function()
			closeCity(journey.origin.city.id)
			if GD.game.closed_cities == 11 then GD.game.stage = "end" end
		end, 10) --allow any tiles to be placed first
	end
	if journey.dest.closed then
		Wait.frames(function()
			closeCity(journey.dest.city.id)
			if GD.game.closed_cities == 11 then GD.game.stage = "end" end
		end, 10) --allow any tiles to be placed first
	end
	updateCityStrengths()
	updateScores()
	GD.game.journey_completed = true
	local board = getObjectFromGUID(C.board_guid)
	board_UI_setAttribute(journey.player_color.."DonePanel","active","true")
	board_UI_setAttribute(journey.player_color.."UndoPanel","active","true")
	-- end
end

--[[ *****************************
Close a city.  Called when all bridges are gone.
Set closed state and put a marker on the city.
********************************]]
function closeCity(city_id)
	if env.test.trace then log("closeCity(): "..tostring(city_id)) end
	if GD.game.undo[1] == nil then GD.game.undo[1] = {} end
	if GD.game.undo[1].markers == nil then GD.game.undo[1].markers = {} end
	local undo = {}
	GD.game.closed_cities = GD.game.closed_cities + 1
	local city = GD.cities[city_id]
	city.closed = true
	undo.city_id = city_id
	for g,md in pairs(C.markers) do
		if not(contains(GD.game.used_markers, g)) then
			local pos = Vector(city.pos)
			pos.y = pos.y + 1
			local m = getObjectFromGUID(g)
			m.setLock(false)
			m.setPositionSmooth(pos,false,false)
			m.setPosition(pos)
			Wait.condition(function() m.setLock(true) end, function() return m.resting or m.isDestroyed() end, 5)
			Wait.time(function() m.setLock(true) end, 2)
			table.insert(GD.game.used_markers, g)
			undo.guid = g
			break
		end
	end
	table.insert(GD.game.undo[1].markers, undo)
	for g,td in pairs(GD.cities[city_id].tiles) do
		if td ~= nil then getObjectFromGUID(g).clearButtons() end
	end
	table.insert(GD.game.undo, {action="close_city",id=city_id})
end

--[[ *****************************
Return a tile to the original player position
********************************]]
function returnTile(tile_guid)
	if env.test.trace then log("returnTile(): "..tostring(tile_guid)) end
	local snap_back = C.tiles[tile_guid].p
	local pcol = C.tiles[tile_guid].c
	local type = C.tiles[tile_guid].t
	assert(snap_back,"ERROR: returnTile(): failed to locate snap back pos for "..tostring(tile_guid))
	local tile = getObjectFromGUID(tile_guid)
	assert(tile, "ERROR: returnTile(): no object for tile guid "..tostring(tile_guid))
	clearDecal(tile_guid)
	tile.setLock(false)
	tile.setVelocity(Vector(0,0,0))
	tile.setPosition(snap_back)
	GD.game.players[pcol].played_tiles[tile_guid] = nil
	GD.game.players[pcol].unplayed_tiles[tile_guid] = type
end

--[[ *****************************
Return true if city tile list contains at least one student for player color
********************************]]
function hasStudent(tiles, pcol)
	for _,td in pairs(tiles) do
		if td.c == pcol and td.r == "student" then return true end
	end
	return false
end

--[[ *****************************
Enable valid buttons according to student journey limitations in rules
The "downArrow" is moving from smaller number city to bigger.  "upArrow" is moving from bigger to smaller.
Only enable arrows where player has at least one student in source city (city moved from)
********************************]]
function enableBridgeButtons(pcol)
	if env.test.trace then log("enableBridgeButtons(): "..pcol) end
	--First disable all arrows and UI panels
	for g,bd in pairs(GD.bridges) do
		if bd.intact then
			bridge_UI_setAttribute(g,"upPanel","active","false")
			bridge_UI_setAttribute(g,"downPanel","active","false")
			bridge_UI_setAttribute(g,"mainPanel","active","false")
		end
	end
	--Search all city -> neighbor paths and enable arrows if at least one source student for player
	for _,city in ipairs(GD.cities) do
		if hasStudent(city.tiles, pcol) then
			--enable all neighbor paths
			for _,neighbor in ipairs(city.neighbors) do
				local bridge = getObjectFromGUID(C.bridges[neighbor.bridge].guid)
				if bridge then
					if neighbor.id > city.id then
						--up arrow
						bridge_UI_setAttribute(bridge.getGUID(),"upPanel","active","true")
					else
						--down arrow
						bridge_UI_setAttribute(bridge.getGUID(),"downPanel","active","true")
					end
					bridge_UI_setAttribute(bridge.getGUID(),"mainPanel","active","true")
				end
			end
		end
	end
end

--[[ *****************************
Disable the arrow buttons on all bridges.
********************************]]
function disableBridgeButtons()
	for g,bd in pairs(GD.bridges) do
		if bd.intact then bridge_UI_setAttribute(g,"mainPanel","active","false") end
	end
end

--[[ *****************************
Add a thick cyan border to a tile, hovering just above it.
Used to indicate a tile is a student.
********************************]]
function addDecal(tile_guid)
	local params = {
    name = "thick-cyan-box",
    position = {["x"]=0,["y"]=0.25,["z"]=0},
    rotation = {["x"]=90,["y"]=180,["z"]=0},
		scale = {["x"]=2,["y"]=2,["z"]=1},
    url = C.student_border_url
  }
	local tile = getObjectFromGUID(tile_guid)
	assert(tile,"ERROR: addDecal(): No object for guid "..tostring(tile_guid))
	tile.addDecal(params)
end

--[[ *****************************
Clear the cyan border from a tile.
********************************]]
function clearDecal(tile_guid)
	local tile = getObjectFromGUID(tile_guid)
	assert(tile,"ERROR: clearDecal(): No object for guid "..tostring(tile_guid))
	tile.setDecals({})
end

--[[ *****************************
Handler for UI button clicks
********************************]]
function buttonClick(player, btn, id)
	if env.test.trace then log("buttonClick(): Player: "..player.color..", id: "..id..", mouse: "..tostring(btn)) end
	local pcol = Split(id,'-')[1]
	if pcol ~= "journey" then
		if player.color ~= pcol then return end --ignore other players
	end
	if player.color ~= GD.game.player_order[GD.game.current_player] then return end
	local action = Split(id,'-')[2]
	if env.test.debug then log("action is "..action) end
	local board = getObjectFromGUID(C.board_guid)
	if action == "done" then
		if GD.game.stage == "placement" then
			if GD.game.masters_placed == 7 * #GD.game.player_order then
				broadcastToAll("All initial masters placed, start game play!")
				GD.game.stage = "play"
				UI_setAttribute("statusTitle","text","Game Play")
				for g,_ in pairs(C.tiles) do
					local tile = getObjectFromGUID(g)
					if tile then tile.interactable = true end
				end
			end
		end
		if GD.game.stage == "end" then
			broadcastToAll("GAME IS OVER!")
			if env.test.debug then log(GD.game.scores) end
			for _,pcol in ipairs(GD.game.player_order) do
				board_UI_setAttribute(params.pcol.."buttonPanel","active","false")
			end
			for g,_ in pairs(C.tiles) do
				local tile = getObjectFromGUID(g)
				if tile then tile.interactable = false end
			end
			return
		end
		setActivePlayer()
	elseif action == "undo" then
		undo(player.color)
	elseif action == "enableJourney" then
		enableBridgeButtons(pcol)
		board_UI_setAttribute(pcol.."JourneyPanel","active","false")
		board_UI_setAttribute(pcol.."UndoPanel","active","true")
		board_UI_setAttribute(pcol.."DonePanel","active","false")
		table.insert(GD.game.undo, {action = "select-journey"})
		UI_setAttribute("statusActiveAction","text","Student Journey")
	else
		log("ERROR: buttonClick(): No recognized action.")
		return
	end
end

--[[ *****************************
Button handler for Student Journey preview dialog.
********************************]]
function journeyDialogClick(player, btn, id)
	if env.test.trace then log("journeyDialogClick(): Player: "..player.color..", id: "..id) end
	if player.color ~= GD.game.player_order[GD.game.current_player] then return end
	if id == "js_ok" then
		UI_setAttribute("journeyAckPanel","visibility","Pink")
		disableBridgeButtons()
		board_UI_setAttribute(player.color.."DonePanel","active","true")
		board_UI_setAttribute(player.color.."UndoPanel","active","true")
		board_UI_setAttribute(player.color.."JourneyPanel","active","false")
		processJourney()
	elseif id == "js_cancel" then
		UI_setAttribute("journeyAckPanel","visibility","Pink")
		enableBridgeButtons(player.color)
		board_UI_setAttribute(player.color.."UndoPanel","active","true")
		GD.game.undo = {}
		table.insert(GD.game.undo, {action = "select-journey"})
		UI_setAttribute("statusActiveAction","text","Student Journey")
	else
		log("ERROR: journeyDialogClick(): No recognized action.")
		return
	end
end

--//////////////////////////////////////////////////////////////////////////////////////////////////////

--[[ DEV ONLY: build metadata code of objects selected and paste to Notes. ]]
function getPositions(pcol)
  local stuff = Player[pcol].getSelectedObjects()
  local s = ""
  for _,o in ipairs(stuff) do
    local p = o.getPosition()
    -- local t = '["'..o.getGUID()..'"]={t="'..o.getTags()[1]..'", c="'..o.getGMNotes()..'", p={x='..tostring(p.x)..", y="..tostring(p.y)..", z="..tostring(p.z).."},},"
    local t = '["'..o.getGUID()..'"]={p={x='..tostring(p.x)..", y="..tostring(p.y)..", z="..tostring(p.z).."},},"
    log(t)
    s = s .. t .. '\n'
  end
  if s ~= "" then
    Notes.setNotes(s)
  end
end

require("tts-bosl/Constants")
require("tts-lib/utils")
